// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know...
// Generated by updateHeaders.sh 







Headers::Type H_Vias::getTypeNum() const {return Headers::Via;} void H_Vias::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Vias::H_Vias() { Headers::CommaTokenizing[Headers::Via+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Via+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Via+1] = "Via"; Headers::Multi[Headers::Via+1] = true; HeaderBase::theHeaderInstances[Headers::Via+1] = this; } ParserContainer<Via>& H_Vias::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Via>*>(container); } ParserContainerBase* H_Vias::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Via>(hfvs,Headers::Via); } H_Vias resip::h_Vias;
Headers::Type H_MaxForwards::getTypeNum() const {return Headers::MaxForwards;} void H_MaxForwards::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_MaxForwards::H_MaxForwards() { Headers::CommaTokenizing[Headers::MaxForwards+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::MaxForwards+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::MaxForwards+1] = "Max-Forwards"; Headers::Multi[Headers::MaxForwards+1] = false; HeaderBase::theHeaderInstances[Headers::MaxForwards+1] = this; } UInt32Category& H_MaxForwards::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<UInt32Category>*>(container)->front(); } ParserContainerBase* H_MaxForwards::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<UInt32Category>(hfvs,Headers::MaxForwards); } H_MaxForwards resip::h_MaxForwards;
Headers::Type H_Routes::getTypeNum() const {return Headers::Route;} void H_Routes::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Routes::H_Routes() { Headers::CommaTokenizing[Headers::Route+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Route+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Route+1] = "Route"; Headers::Multi[Headers::Route+1] = true; HeaderBase::theHeaderInstances[Headers::Route+1] = this; } ParserContainer<NameAddr>& H_Routes::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<NameAddr>*>(container); } ParserContainerBase* H_Routes::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::Route); } H_Routes resip::h_Routes;
Headers::Type H_RecordRoutes::getTypeNum() const {return Headers::RecordRoute;} void H_RecordRoutes::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_RecordRoutes::H_RecordRoutes() { Headers::CommaTokenizing[Headers::RecordRoute+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::RecordRoute+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::RecordRoute+1] = "Record-Route"; Headers::Multi[Headers::RecordRoute+1] = true; HeaderBase::theHeaderInstances[Headers::RecordRoute+1] = this; } ParserContainer<NameAddr>& H_RecordRoutes::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<NameAddr>*>(container); } ParserContainerBase* H_RecordRoutes::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::RecordRoute); } H_RecordRoutes resip::h_RecordRoutes;
Headers::Type H_Paths::getTypeNum() const {return Headers::Path;} void H_Paths::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Paths::H_Paths() { Headers::CommaTokenizing[Headers::Path+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Path+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Path+1] = "Path"; Headers::Multi[Headers::Path+1] = true; HeaderBase::theHeaderInstances[Headers::Path+1] = this; } ParserContainer<NameAddr>& H_Paths::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<NameAddr>*>(container); } ParserContainerBase* H_Paths::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::Path); } H_Paths resip::h_Paths;
Headers::Type H_ServiceRoutes::getTypeNum() const {return Headers::ServiceRoute;} void H_ServiceRoutes::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_ServiceRoutes::H_ServiceRoutes() { Headers::CommaTokenizing[Headers::ServiceRoute+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ServiceRoute+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::ServiceRoute+1] = "Service-Route"; Headers::Multi[Headers::ServiceRoute+1] = true; HeaderBase::theHeaderInstances[Headers::ServiceRoute+1] = this; } ParserContainer<NameAddr>& H_ServiceRoutes::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<NameAddr>*>(container); } ParserContainerBase* H_ServiceRoutes::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::ServiceRoute); } H_ServiceRoutes resip::h_ServiceRoutes;
Headers::Type H_ProxyRequires::getTypeNum() const {return Headers::ProxyRequire;} void H_ProxyRequires::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_ProxyRequires::H_ProxyRequires() { Headers::CommaTokenizing[Headers::ProxyRequire+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ProxyRequire+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::ProxyRequire+1] = "Proxy-Require"; Headers::Multi[Headers::ProxyRequire+1] = true; HeaderBase::theHeaderInstances[Headers::ProxyRequire+1] = this; } ParserContainer<Token>& H_ProxyRequires::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_ProxyRequires::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::ProxyRequire); } H_ProxyRequires resip::h_ProxyRequires;
Headers::Type H_ProxyAuthenticates::getTypeNum() const {return Headers::ProxyAuthenticate;} void H_ProxyAuthenticates::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_ProxyAuthenticates::H_ProxyAuthenticates() { Headers::CommaTokenizing[Headers::ProxyAuthenticate+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ProxyAuthenticate+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::ProxyAuthenticate+1] = "Proxy-Authenticate"; Headers::Multi[Headers::ProxyAuthenticate+1] = true; HeaderBase::theHeaderInstances[Headers::ProxyAuthenticate+1] = this; } ParserContainer<Auth>& H_ProxyAuthenticates::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Auth>*>(container); } ParserContainerBase* H_ProxyAuthenticates::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Auth>(hfvs,Headers::ProxyAuthenticate); } H_ProxyAuthenticates resip::h_ProxyAuthenticates;
Headers::Type H_Identity::getTypeNum() const {return Headers::Identity;} void H_Identity::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Identity::H_Identity() { Headers::CommaTokenizing[Headers::Identity+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Identity+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Identity+1] = "Identity"; Headers::Multi[Headers::Identity+1] = false; HeaderBase::theHeaderInstances[Headers::Identity+1] = this; } StringCategory& H_Identity::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<StringCategory>*>(container)->front(); } ParserContainerBase* H_Identity::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<StringCategory>(hfvs,Headers::Identity); } H_Identity resip::h_Identity;
Headers::Type H_IdentityInfo::getTypeNum() const {return Headers::IdentityInfo;} void H_IdentityInfo::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_IdentityInfo::H_IdentityInfo() { Headers::CommaTokenizing[Headers::IdentityInfo+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::IdentityInfo+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::IdentityInfo+1] = "Identity-Info"; Headers::Multi[Headers::IdentityInfo+1] = false; HeaderBase::theHeaderInstances[Headers::IdentityInfo+1] = this; } GenericUri& H_IdentityInfo::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<GenericUri>*>(container)->front(); } ParserContainerBase* H_IdentityInfo::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<GenericUri>(hfvs,Headers::IdentityInfo); } H_IdentityInfo resip::h_IdentityInfo;
Headers::Type H_Requires::getTypeNum() const {return Headers::Require;} void H_Requires::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Requires::H_Requires() { Headers::CommaTokenizing[Headers::Require+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Require+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Require+1] = "Require"; Headers::Multi[Headers::Require+1] = true; HeaderBase::theHeaderInstances[Headers::Require+1] = this; } ParserContainer<Token>& H_Requires::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_Requires::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::Require); } H_Requires resip::h_Requires;
Headers::Type H_Contacts::getTypeNum() const {return Headers::Contact;} void H_Contacts::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Contacts::H_Contacts() { Headers::CommaTokenizing[Headers::Contact+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Contact+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Contact+1] = "Contact"; Headers::Multi[Headers::Contact+1] = true; HeaderBase::theHeaderInstances[Headers::Contact+1] = this; } ParserContainer<NameAddr>& H_Contacts::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<NameAddr>*>(container); } ParserContainerBase* H_Contacts::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::Contact); } H_Contacts resip::h_Contacts;
Headers::Type H_To::getTypeNum() const {return Headers::To;} void H_To::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_To::H_To() { Headers::CommaTokenizing[Headers::To+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::To+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::To+1] = "To"; Headers::Multi[Headers::To+1] = false; HeaderBase::theHeaderInstances[Headers::To+1] = this; } NameAddr& H_To::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<NameAddr>*>(container)->front(); } ParserContainerBase* H_To::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::To); } H_To resip::h_To;
Headers::Type H_From::getTypeNum() const {return Headers::From;} void H_From::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_From::H_From() { Headers::CommaTokenizing[Headers::From+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::From+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::From+1] = "From"; Headers::Multi[Headers::From+1] = false; HeaderBase::theHeaderInstances[Headers::From+1] = this; } NameAddr& H_From::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<NameAddr>*>(container)->front(); } ParserContainerBase* H_From::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::From); } H_From resip::h_From;
Headers::Type H_CallID::getTypeNum() const {return Headers::CallID;} void H_CallID::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_CallID::H_CallID() { Headers::CommaTokenizing[Headers::CallID+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::CallID+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::CallID+1] = "Call-ID"; Headers::Multi[Headers::CallID+1] = false; HeaderBase::theHeaderInstances[Headers::CallID+1] = this; } CallId& H_CallID::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<CallId>*>(container)->front(); } ParserContainerBase* H_CallID::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<CallId>(hfvs,Headers::CallID); } H_CallID resip::h_CallID;
Headers::Type H_CSeq::getTypeNum() const {return Headers::CSeq;} void H_CSeq::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_CSeq::H_CSeq() { Headers::CommaTokenizing[Headers::CSeq+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::CSeq+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::CSeq+1] = "CSeq"; Headers::Multi[Headers::CSeq+1] = false; HeaderBase::theHeaderInstances[Headers::CSeq+1] = this; } CSeqCategory& H_CSeq::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<CSeqCategory>*>(container)->front(); } ParserContainerBase* H_CSeq::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<CSeqCategory>(hfvs,Headers::CSeq); } H_CSeq resip::h_CSeq;
Headers::Type H_Subject::getTypeNum() const {return Headers::Subject;} void H_Subject::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Subject::H_Subject() { Headers::CommaTokenizing[Headers::Subject+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Subject+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Subject+1] = "Subject"; Headers::Multi[Headers::Subject+1] = false; HeaderBase::theHeaderInstances[Headers::Subject+1] = this; } StringCategory& H_Subject::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<StringCategory>*>(container)->front(); } ParserContainerBase* H_Subject::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<StringCategory>(hfvs,Headers::Subject); } H_Subject resip::h_Subject;
Headers::Type H_Expires::getTypeNum() const {return Headers::Expires;} void H_Expires::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Expires::H_Expires() { Headers::CommaTokenizing[Headers::Expires+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Expires+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Expires+1] = "Expires"; Headers::Multi[Headers::Expires+1] = false; HeaderBase::theHeaderInstances[Headers::Expires+1] = this; } ExpiresCategory& H_Expires::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<ExpiresCategory>*>(container)->front(); } ParserContainerBase* H_Expires::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<ExpiresCategory>(hfvs,Headers::Expires); } H_Expires resip::h_Expires;
Headers::Type H_SessionExpires::getTypeNum() const {return Headers::SessionExpires;} void H_SessionExpires::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_SessionExpires::H_SessionExpires() { Headers::CommaTokenizing[Headers::SessionExpires+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::SessionExpires+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::SessionExpires+1] = "Session-Expires"; Headers::Multi[Headers::SessionExpires+1] = false; HeaderBase::theHeaderInstances[Headers::SessionExpires+1] = this; } ExpiresCategory& H_SessionExpires::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<ExpiresCategory>*>(container)->front(); } ParserContainerBase* H_SessionExpires::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<ExpiresCategory>(hfvs,Headers::SessionExpires); } H_SessionExpires resip::h_SessionExpires;
Headers::Type H_MinSE::getTypeNum() const {return Headers::MinSE;} void H_MinSE::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_MinSE::H_MinSE() { Headers::CommaTokenizing[Headers::MinSE+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::MinSE+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::MinSE+1] = "Min-SE"; Headers::Multi[Headers::MinSE+1] = false; HeaderBase::theHeaderInstances[Headers::MinSE+1] = this; } ExpiresCategory& H_MinSE::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<ExpiresCategory>*>(container)->front(); } ParserContainerBase* H_MinSE::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<ExpiresCategory>(hfvs,Headers::MinSE); } H_MinSE resip::h_MinSE;
Headers::Type H_Accepts::getTypeNum() const {return Headers::Accept;} void H_Accepts::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Accepts::H_Accepts() { Headers::CommaTokenizing[Headers::Accept+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Accept+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Accept+1] = "Accept"; Headers::Multi[Headers::Accept+1] = true; HeaderBase::theHeaderInstances[Headers::Accept+1] = this; } ParserContainer<Mime>& H_Accepts::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Mime>*>(container); } ParserContainerBase* H_Accepts::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Mime>(hfvs,Headers::Accept); } H_Accepts resip::h_Accepts;
Headers::Type H_AcceptEncodings::getTypeNum() const {return Headers::AcceptEncoding;} void H_AcceptEncodings::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_AcceptEncodings::H_AcceptEncodings() { Headers::CommaTokenizing[Headers::AcceptEncoding+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::AcceptEncoding+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::AcceptEncoding+1] = "Accept-Encoding"; Headers::Multi[Headers::AcceptEncoding+1] = true; HeaderBase::theHeaderInstances[Headers::AcceptEncoding+1] = this; } ParserContainer<Token>& H_AcceptEncodings::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_AcceptEncodings::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::AcceptEncoding); } H_AcceptEncodings resip::h_AcceptEncodings;
Headers::Type H_AcceptLanguages::getTypeNum() const {return Headers::AcceptLanguage;} void H_AcceptLanguages::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_AcceptLanguages::H_AcceptLanguages() { Headers::CommaTokenizing[Headers::AcceptLanguage+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::AcceptLanguage+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::AcceptLanguage+1] = "Accept-Language"; Headers::Multi[Headers::AcceptLanguage+1] = true; HeaderBase::theHeaderInstances[Headers::AcceptLanguage+1] = this; } ParserContainer<Token>& H_AcceptLanguages::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_AcceptLanguages::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::AcceptLanguage); } H_AcceptLanguages resip::h_AcceptLanguages;
Headers::Type H_AlertInfos::getTypeNum() const {return Headers::AlertInfo;} void H_AlertInfos::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_AlertInfos::H_AlertInfos() { Headers::CommaTokenizing[Headers::AlertInfo+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::AlertInfo+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::AlertInfo+1] = "Alert-Info"; Headers::Multi[Headers::AlertInfo+1] = true; HeaderBase::theHeaderInstances[Headers::AlertInfo+1] = this; } ParserContainer<GenericUri>& H_AlertInfos::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<GenericUri>*>(container); } ParserContainerBase* H_AlertInfos::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<GenericUri>(hfvs,Headers::AlertInfo); } H_AlertInfos resip::h_AlertInfos;
Headers::Type H_Allows::getTypeNum() const {return Headers::Allow;} void H_Allows::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Allows::H_Allows() { Headers::CommaTokenizing[Headers::Allow+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Allow+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Allow+1] = "Allow"; Headers::Multi[Headers::Allow+1] = true; HeaderBase::theHeaderInstances[Headers::Allow+1] = this; } ParserContainer<Token>& H_Allows::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_Allows::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::Allow); } H_Allows resip::h_Allows;
Headers::Type H_AuthenticationInfo::getTypeNum() const {return Headers::AuthenticationInfo;} void H_AuthenticationInfo::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_AuthenticationInfo::H_AuthenticationInfo() { Headers::CommaTokenizing[Headers::AuthenticationInfo+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::AuthenticationInfo+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::AuthenticationInfo+1] = "Authentication-Info"; Headers::Multi[Headers::AuthenticationInfo+1] = false; HeaderBase::theHeaderInstances[Headers::AuthenticationInfo+1] = this; } Auth& H_AuthenticationInfo::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Auth>*>(container)->front(); } ParserContainerBase* H_AuthenticationInfo::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Auth>(hfvs,Headers::AuthenticationInfo); } H_AuthenticationInfo resip::h_AuthenticationInfo;
Headers::Type H_CallInfos::getTypeNum() const {return Headers::CallInfo;} void H_CallInfos::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_CallInfos::H_CallInfos() { Headers::CommaTokenizing[Headers::CallInfo+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::CallInfo+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::CallInfo+1] = "Call-Info"; Headers::Multi[Headers::CallInfo+1] = true; HeaderBase::theHeaderInstances[Headers::CallInfo+1] = this; } ParserContainer<GenericUri>& H_CallInfos::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<GenericUri>*>(container); } ParserContainerBase* H_CallInfos::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<GenericUri>(hfvs,Headers::CallInfo); } H_CallInfos resip::h_CallInfos;
Headers::Type H_ContentDisposition::getTypeNum() const {return Headers::ContentDisposition;} void H_ContentDisposition::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_ContentDisposition::H_ContentDisposition() { Headers::CommaTokenizing[Headers::ContentDisposition+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ContentDisposition+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::ContentDisposition+1] = "Content-Disposition"; Headers::Multi[Headers::ContentDisposition+1] = false; HeaderBase::theHeaderInstances[Headers::ContentDisposition+1] = this; } Token& H_ContentDisposition::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_ContentDisposition::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::ContentDisposition); } H_ContentDisposition resip::h_ContentDisposition;
Headers::Type H_ContentEncoding::getTypeNum() const {return Headers::ContentEncoding;} void H_ContentEncoding::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_ContentEncoding::H_ContentEncoding() { Headers::CommaTokenizing[Headers::ContentEncoding+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ContentEncoding+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::ContentEncoding+1] = "Content-Encoding"; Headers::Multi[Headers::ContentEncoding+1] = false; HeaderBase::theHeaderInstances[Headers::ContentEncoding+1] = this; } Token& H_ContentEncoding::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_ContentEncoding::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::ContentEncoding); } H_ContentEncoding resip::h_ContentEncoding;
Headers::Type H_ContentId::getTypeNum() const {return Headers::ContentId;} void H_ContentId::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_ContentId::H_ContentId() { Headers::CommaTokenizing[Headers::ContentId+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ContentId+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::ContentId+1] = "Content-ID"; Headers::Multi[Headers::ContentId+1] = false; HeaderBase::theHeaderInstances[Headers::ContentId+1] = this; } Token& H_ContentId::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_ContentId::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::ContentId); } H_ContentId resip::h_ContentId;
Headers::Type H_ContentLanguages::getTypeNum() const {return Headers::ContentLanguage;} void H_ContentLanguages::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_ContentLanguages::H_ContentLanguages() { Headers::CommaTokenizing[Headers::ContentLanguage+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ContentLanguage+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::ContentLanguage+1] = "Content-Language"; Headers::Multi[Headers::ContentLanguage+1] = true; HeaderBase::theHeaderInstances[Headers::ContentLanguage+1] = this; } ParserContainer<Token>& H_ContentLanguages::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_ContentLanguages::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::ContentLanguage); } H_ContentLanguages resip::h_ContentLanguages;
Headers::Type H_ContentTransferEncoding::getTypeNum() const {return Headers::ContentTransferEncoding;} void H_ContentTransferEncoding::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_ContentTransferEncoding::H_ContentTransferEncoding() { Headers::CommaTokenizing[Headers::ContentTransferEncoding+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ContentTransferEncoding+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::ContentTransferEncoding+1] = "Content-Transfer-Encoding"; Headers::Multi[Headers::ContentTransferEncoding+1] = false; HeaderBase::theHeaderInstances[Headers::ContentTransferEncoding+1] = this; } StringCategory& H_ContentTransferEncoding::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<StringCategory>*>(container)->front(); } ParserContainerBase* H_ContentTransferEncoding::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<StringCategory>(hfvs,Headers::ContentTransferEncoding); } H_ContentTransferEncoding resip::h_ContentTransferEncoding;
Headers::Type H_ContentType::getTypeNum() const {return Headers::ContentType;} void H_ContentType::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_ContentType::H_ContentType() { Headers::CommaTokenizing[Headers::ContentType+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ContentType+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::ContentType+1] = "Content-Type"; Headers::Multi[Headers::ContentType+1] = false; HeaderBase::theHeaderInstances[Headers::ContentType+1] = this; } Mime& H_ContentType::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Mime>*>(container)->front(); } ParserContainerBase* H_ContentType::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Mime>(hfvs,Headers::ContentType); } H_ContentType resip::h_ContentType;
Headers::Type H_Date::getTypeNum() const {return Headers::Date;} void H_Date::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Date::H_Date() { Headers::CommaTokenizing[Headers::Date+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Date+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Date+1] = "Date"; Headers::Multi[Headers::Date+1] = false; HeaderBase::theHeaderInstances[Headers::Date+1] = this; } DateCategory& H_Date::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<DateCategory>*>(container)->front(); } ParserContainerBase* H_Date::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<DateCategory>(hfvs,Headers::Date); } H_Date resip::h_Date;
Headers::Type H_ErrorInfos::getTypeNum() const {return Headers::ErrorInfo;} void H_ErrorInfos::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_ErrorInfos::H_ErrorInfos() { Headers::CommaTokenizing[Headers::ErrorInfo+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ErrorInfo+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::ErrorInfo+1] = "Error-Info"; Headers::Multi[Headers::ErrorInfo+1] = true; HeaderBase::theHeaderInstances[Headers::ErrorInfo+1] = this; } ParserContainer<GenericUri>& H_ErrorInfos::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<GenericUri>*>(container); } ParserContainerBase* H_ErrorInfos::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<GenericUri>(hfvs,Headers::ErrorInfo); } H_ErrorInfos resip::h_ErrorInfos;
Headers::Type H_InReplyTo::getTypeNum() const {return Headers::InReplyTo;} void H_InReplyTo::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_InReplyTo::H_InReplyTo() { Headers::CommaTokenizing[Headers::InReplyTo+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::InReplyTo+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::InReplyTo+1] = "In-Reply-To"; Headers::Multi[Headers::InReplyTo+1] = false; HeaderBase::theHeaderInstances[Headers::InReplyTo+1] = this; } CallId& H_InReplyTo::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<CallId>*>(container)->front(); } ParserContainerBase* H_InReplyTo::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<CallId>(hfvs,Headers::InReplyTo); } H_InReplyTo resip::h_InReplyTo;
Headers::Type H_MinExpires::getTypeNum() const {return Headers::MinExpires;} void H_MinExpires::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_MinExpires::H_MinExpires() { Headers::CommaTokenizing[Headers::MinExpires+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::MinExpires+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::MinExpires+1] = "Min-Expires"; Headers::Multi[Headers::MinExpires+1] = false; HeaderBase::theHeaderInstances[Headers::MinExpires+1] = this; } UInt32Category& H_MinExpires::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<UInt32Category>*>(container)->front(); } ParserContainerBase* H_MinExpires::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<UInt32Category>(hfvs,Headers::MinExpires); } H_MinExpires resip::h_MinExpires;
Headers::Type H_MIMEVersion::getTypeNum() const {return Headers::MIMEVersion;} void H_MIMEVersion::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_MIMEVersion::H_MIMEVersion() { Headers::CommaTokenizing[Headers::MIMEVersion+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::MIMEVersion+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::MIMEVersion+1] = "MIME-Version"; Headers::Multi[Headers::MIMEVersion+1] = false; HeaderBase::theHeaderInstances[Headers::MIMEVersion+1] = this; } Token& H_MIMEVersion::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_MIMEVersion::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::MIMEVersion); } H_MIMEVersion resip::h_MIMEVersion;
Headers::Type H_Organization::getTypeNum() const {return Headers::Organization;} void H_Organization::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Organization::H_Organization() { Headers::CommaTokenizing[Headers::Organization+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Organization+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Organization+1] = "Organization"; Headers::Multi[Headers::Organization+1] = false; HeaderBase::theHeaderInstances[Headers::Organization+1] = this; } StringCategory& H_Organization::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<StringCategory>*>(container)->front(); } ParserContainerBase* H_Organization::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<StringCategory>(hfvs,Headers::Organization); } H_Organization resip::h_Organization;
Headers::Type H_Priority::getTypeNum() const {return Headers::Priority;} void H_Priority::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Priority::H_Priority() { Headers::CommaTokenizing[Headers::Priority+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Priority+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Priority+1] = "Priority"; Headers::Multi[Headers::Priority+1] = false; HeaderBase::theHeaderInstances[Headers::Priority+1] = this; } Token& H_Priority::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_Priority::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::Priority); } H_Priority resip::h_Priority;
Headers::Type H_ProxyAuthorizations::getTypeNum() const {return Headers::ProxyAuthorization;} void H_ProxyAuthorizations::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_ProxyAuthorizations::H_ProxyAuthorizations() { Headers::CommaTokenizing[Headers::ProxyAuthorization+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ProxyAuthorization+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::ProxyAuthorization+1] = "Proxy-Authorization"; Headers::Multi[Headers::ProxyAuthorization+1] = true; HeaderBase::theHeaderInstances[Headers::ProxyAuthorization+1] = this; } ParserContainer<Auth>& H_ProxyAuthorizations::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Auth>*>(container); } ParserContainerBase* H_ProxyAuthorizations::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Auth>(hfvs,Headers::ProxyAuthorization); } H_ProxyAuthorizations resip::h_ProxyAuthorizations;
Headers::Type H_ReplyTo::getTypeNum() const {return Headers::ReplyTo;} void H_ReplyTo::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_ReplyTo::H_ReplyTo() { Headers::CommaTokenizing[Headers::ReplyTo+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ReplyTo+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::ReplyTo+1] = "Reply-To"; Headers::Multi[Headers::ReplyTo+1] = false; HeaderBase::theHeaderInstances[Headers::ReplyTo+1] = this; } NameAddr& H_ReplyTo::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<NameAddr>*>(container)->front(); } ParserContainerBase* H_ReplyTo::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::ReplyTo); } H_ReplyTo resip::h_ReplyTo;
Headers::Type H_RetryAfter::getTypeNum() const {return Headers::RetryAfter;} void H_RetryAfter::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_RetryAfter::H_RetryAfter() { Headers::CommaTokenizing[Headers::RetryAfter+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::RetryAfter+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::RetryAfter+1] = "Retry-After"; Headers::Multi[Headers::RetryAfter+1] = false; HeaderBase::theHeaderInstances[Headers::RetryAfter+1] = this; } UInt32Category& H_RetryAfter::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<UInt32Category>*>(container)->front(); } ParserContainerBase* H_RetryAfter::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<UInt32Category>(hfvs,Headers::RetryAfter); } H_RetryAfter resip::h_RetryAfter;
Headers::Type H_Server::getTypeNum() const {return Headers::Server;} void H_Server::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Server::H_Server() { Headers::CommaTokenizing[Headers::Server+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Server+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Server+1] = "Server"; Headers::Multi[Headers::Server+1] = false; HeaderBase::theHeaderInstances[Headers::Server+1] = this; } StringCategory& H_Server::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<StringCategory>*>(container)->front(); } ParserContainerBase* H_Server::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<StringCategory>(hfvs,Headers::Server); } H_Server resip::h_Server;
Headers::Type H_SIPETag::getTypeNum() const {return Headers::SIPETag;} void H_SIPETag::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_SIPETag::H_SIPETag() { Headers::CommaTokenizing[Headers::SIPETag+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::SIPETag+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::SIPETag+1] = "SIP-ETag"; Headers::Multi[Headers::SIPETag+1] = false; HeaderBase::theHeaderInstances[Headers::SIPETag+1] = this; } Token& H_SIPETag::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_SIPETag::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::SIPETag); } H_SIPETag resip::h_SIPETag;
Headers::Type H_SIPIfMatch::getTypeNum() const {return Headers::SIPIfMatch;} void H_SIPIfMatch::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_SIPIfMatch::H_SIPIfMatch() { Headers::CommaTokenizing[Headers::SIPIfMatch+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::SIPIfMatch+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::SIPIfMatch+1] = "SIP-If-Match"; Headers::Multi[Headers::SIPIfMatch+1] = false; HeaderBase::theHeaderInstances[Headers::SIPIfMatch+1] = this; } Token& H_SIPIfMatch::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_SIPIfMatch::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::SIPIfMatch); } H_SIPIfMatch resip::h_SIPIfMatch;
Headers::Type H_Supporteds::getTypeNum() const {return Headers::Supported;} void H_Supporteds::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Supporteds::H_Supporteds() { Headers::CommaTokenizing[Headers::Supported+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Supported+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Supported+1] = "Supported"; Headers::Multi[Headers::Supported+1] = true; HeaderBase::theHeaderInstances[Headers::Supported+1] = this; } ParserContainer<Token>& H_Supporteds::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_Supporteds::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::Supported); } H_Supporteds resip::h_Supporteds;
Headers::Type H_Timestamp::getTypeNum() const {return Headers::Timestamp;} void H_Timestamp::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Timestamp::H_Timestamp() { Headers::CommaTokenizing[Headers::Timestamp+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Timestamp+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Timestamp+1] = "Timestamp"; Headers::Multi[Headers::Timestamp+1] = false; HeaderBase::theHeaderInstances[Headers::Timestamp+1] = this; } StringCategory& H_Timestamp::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<StringCategory>*>(container)->front(); } ParserContainerBase* H_Timestamp::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<StringCategory>(hfvs,Headers::Timestamp); } H_Timestamp resip::h_Timestamp;
Headers::Type H_Unsupporteds::getTypeNum() const {return Headers::Unsupported;} void H_Unsupporteds::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Unsupporteds::H_Unsupporteds() { Headers::CommaTokenizing[Headers::Unsupported+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Unsupported+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Unsupported+1] = "Unsupported"; Headers::Multi[Headers::Unsupported+1] = true; HeaderBase::theHeaderInstances[Headers::Unsupported+1] = this; } ParserContainer<Token>& H_Unsupporteds::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_Unsupporteds::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::Unsupported); } H_Unsupporteds resip::h_Unsupporteds;
Headers::Type H_UserAgent::getTypeNum() const {return Headers::UserAgent;} void H_UserAgent::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_UserAgent::H_UserAgent() { Headers::CommaTokenizing[Headers::UserAgent+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::UserAgent+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::UserAgent+1] = "User-Agent"; Headers::Multi[Headers::UserAgent+1] = false; HeaderBase::theHeaderInstances[Headers::UserAgent+1] = this; } StringCategory& H_UserAgent::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<StringCategory>*>(container)->front(); } ParserContainerBase* H_UserAgent::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<StringCategory>(hfvs,Headers::UserAgent); } H_UserAgent resip::h_UserAgent;
Headers::Type H_Warnings::getTypeNum() const {return Headers::Warning;} void H_Warnings::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Warnings::H_Warnings() { Headers::CommaTokenizing[Headers::Warning+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Warning+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Warning+1] = "Warning"; Headers::Multi[Headers::Warning+1] = true; HeaderBase::theHeaderInstances[Headers::Warning+1] = this; } ParserContainer<WarningCategory>& H_Warnings::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<WarningCategory>*>(container); } ParserContainerBase* H_Warnings::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<WarningCategory>(hfvs,Headers::Warning); } H_Warnings resip::h_Warnings;
Headers::Type H_WWWAuthenticates::getTypeNum() const {return Headers::WWWAuthenticate;} void H_WWWAuthenticates::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_WWWAuthenticates::H_WWWAuthenticates() { Headers::CommaTokenizing[Headers::WWWAuthenticate+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::WWWAuthenticate+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::WWWAuthenticate+1] = "WWW-Authenticate"; Headers::Multi[Headers::WWWAuthenticate+1] = true; HeaderBase::theHeaderInstances[Headers::WWWAuthenticate+1] = this; } ParserContainer<Auth>& H_WWWAuthenticates::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Auth>*>(container); } ParserContainerBase* H_WWWAuthenticates::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Auth>(hfvs,Headers::WWWAuthenticate); } H_WWWAuthenticates resip::h_WWWAuthenticates;
Headers::Type H_SubscriptionState::getTypeNum() const {return Headers::SubscriptionState;} void H_SubscriptionState::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_SubscriptionState::H_SubscriptionState() { Headers::CommaTokenizing[Headers::SubscriptionState+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::SubscriptionState+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::SubscriptionState+1] = "Subscription-State"; Headers::Multi[Headers::SubscriptionState+1] = false; HeaderBase::theHeaderInstances[Headers::SubscriptionState+1] = this; } Token& H_SubscriptionState::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_SubscriptionState::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::SubscriptionState); } H_SubscriptionState resip::h_SubscriptionState;
Headers::Type H_ReferTo::getTypeNum() const {return Headers::ReferTo;} void H_ReferTo::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_ReferTo::H_ReferTo() { Headers::CommaTokenizing[Headers::ReferTo+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ReferTo+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::ReferTo+1] = "Refer-To"; Headers::Multi[Headers::ReferTo+1] = false; HeaderBase::theHeaderInstances[Headers::ReferTo+1] = this; } NameAddr& H_ReferTo::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<NameAddr>*>(container)->front(); } ParserContainerBase* H_ReferTo::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::ReferTo); } H_ReferTo resip::h_ReferTo;
Headers::Type H_ReferredBy::getTypeNum() const {return Headers::ReferredBy;} void H_ReferredBy::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_ReferredBy::H_ReferredBy() { Headers::CommaTokenizing[Headers::ReferredBy+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ReferredBy+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::ReferredBy+1] = "Referred-By"; Headers::Multi[Headers::ReferredBy+1] = false; HeaderBase::theHeaderInstances[Headers::ReferredBy+1] = this; } NameAddr& H_ReferredBy::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<NameAddr>*>(container)->front(); } ParserContainerBase* H_ReferredBy::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::ReferredBy); } H_ReferredBy resip::h_ReferredBy;
Headers::Type H_Authorizations::getTypeNum() const {return Headers::Authorization;} void H_Authorizations::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Authorizations::H_Authorizations() { Headers::CommaTokenizing[Headers::Authorization+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Authorization+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Authorization+1] = "Authorization"; Headers::Multi[Headers::Authorization+1] = true; HeaderBase::theHeaderInstances[Headers::Authorization+1] = this; } ParserContainer<Auth>& H_Authorizations::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Auth>*>(container); } ParserContainerBase* H_Authorizations::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Auth>(hfvs,Headers::Authorization); } H_Authorizations resip::h_Authorizations;
Headers::Type H_Replaces::getTypeNum() const {return Headers::Replaces;} void H_Replaces::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Replaces::H_Replaces() { Headers::CommaTokenizing[Headers::Replaces+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Replaces+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Replaces+1] = "Replaces"; Headers::Multi[Headers::Replaces+1] = false; HeaderBase::theHeaderInstances[Headers::Replaces+1] = this; } CallId& H_Replaces::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<CallId>*>(container)->front(); } ParserContainerBase* H_Replaces::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<CallId>(hfvs,Headers::Replaces); } H_Replaces resip::h_Replaces;
Headers::Type H_Event::getTypeNum() const {return Headers::Event;} void H_Event::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Event::H_Event() { Headers::CommaTokenizing[Headers::Event+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Event+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Event+1] = "Event"; Headers::Multi[Headers::Event+1] = false; HeaderBase::theHeaderInstances[Headers::Event+1] = this; } Token& H_Event::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_Event::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::Event); } H_Event resip::h_Event;
Headers::Type H_AllowEventss::getTypeNum() const {return Headers::AllowEvents;} void H_AllowEventss::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_AllowEventss::H_AllowEventss() { Headers::CommaTokenizing[Headers::AllowEvents+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::AllowEvents+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::AllowEvents+1] = "Allow-Events"; Headers::Multi[Headers::AllowEvents+1] = true; HeaderBase::theHeaderInstances[Headers::AllowEvents+1] = this; } ParserContainer<Token>& H_AllowEventss::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_AllowEventss::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::AllowEvents); } H_AllowEventss resip::h_AllowEventss;
Headers::Type H_SecurityClients::getTypeNum() const {return Headers::SecurityClient;} void H_SecurityClients::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_SecurityClients::H_SecurityClients() { Headers::CommaTokenizing[Headers::SecurityClient+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::SecurityClient+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::SecurityClient+1] = "Security-Client"; Headers::Multi[Headers::SecurityClient+1] = true; HeaderBase::theHeaderInstances[Headers::SecurityClient+1] = this; } ParserContainer<Token>& H_SecurityClients::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_SecurityClients::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::SecurityClient); } H_SecurityClients resip::h_SecurityClients;
Headers::Type H_SecurityServers::getTypeNum() const {return Headers::SecurityServer;} void H_SecurityServers::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_SecurityServers::H_SecurityServers() { Headers::CommaTokenizing[Headers::SecurityServer+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::SecurityServer+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::SecurityServer+1] = "Security-Server"; Headers::Multi[Headers::SecurityServer+1] = true; HeaderBase::theHeaderInstances[Headers::SecurityServer+1] = this; } ParserContainer<Token>& H_SecurityServers::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_SecurityServers::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::SecurityServer); } H_SecurityServers resip::h_SecurityServers;
Headers::Type H_SecurityVerifys::getTypeNum() const {return Headers::SecurityVerify;} void H_SecurityVerifys::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_SecurityVerifys::H_SecurityVerifys() { Headers::CommaTokenizing[Headers::SecurityVerify+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::SecurityVerify+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::SecurityVerify+1] = "Security-Verify"; Headers::Multi[Headers::SecurityVerify+1] = true; HeaderBase::theHeaderInstances[Headers::SecurityVerify+1] = this; } ParserContainer<Token>& H_SecurityVerifys::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_SecurityVerifys::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::SecurityVerify); } H_SecurityVerifys resip::h_SecurityVerifys;
Headers::Type H_RSeq::getTypeNum() const {return Headers::RSeq;} void H_RSeq::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_RSeq::H_RSeq() { Headers::CommaTokenizing[Headers::RSeq+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::RSeq+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::RSeq+1] = "RSeq"; Headers::Multi[Headers::RSeq+1] = false; HeaderBase::theHeaderInstances[Headers::RSeq+1] = this; } UInt32Category& H_RSeq::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<UInt32Category>*>(container)->front(); } ParserContainerBase* H_RSeq::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<UInt32Category>(hfvs,Headers::RSeq); } H_RSeq resip::h_RSeq;
Headers::Type H_RAck::getTypeNum() const {return Headers::RAck;} void H_RAck::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_RAck::H_RAck() { Headers::CommaTokenizing[Headers::RAck+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::RAck+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::RAck+1] = "RAck"; Headers::Multi[Headers::RAck+1] = false; HeaderBase::theHeaderInstances[Headers::RAck+1] = this; } RAckCategory& H_RAck::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<RAckCategory>*>(container)->front(); } ParserContainerBase* H_RAck::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<RAckCategory>(hfvs,Headers::RAck); } H_RAck resip::h_RAck;
Headers::Type H_Reasons::getTypeNum() const {return Headers::Reason;} void H_Reasons::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Reasons::H_Reasons() { Headers::CommaTokenizing[Headers::Reason+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Reason+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Reason+1] = "Reason"; Headers::Multi[Headers::Reason+1] = true; HeaderBase::theHeaderInstances[Headers::Reason+1] = this; } ParserContainer<Token>& H_Reasons::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_Reasons::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::Reason); } H_Reasons resip::h_Reasons;
Headers::Type H_Privacys::getTypeNum() const {return Headers::Privacy;} void H_Privacys::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_Privacys::H_Privacys() { Headers::CommaTokenizing[Headers::Privacy+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Privacy+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::Privacy+1] = "Privacy"; Headers::Multi[Headers::Privacy+1] = true; HeaderBase::theHeaderInstances[Headers::Privacy+1] = this; } ParserContainer<Token>& H_Privacys::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_Privacys::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::Privacy); } H_Privacys resip::h_Privacys;
Headers::Type H_RequestDispositions::getTypeNum() const {return Headers::RequestDisposition;} void H_RequestDispositions::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_RequestDispositions::H_RequestDispositions() { Headers::CommaTokenizing[Headers::RequestDisposition+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::RequestDisposition+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::RequestDisposition+1] = "Request-Disposition"; Headers::Multi[Headers::RequestDisposition+1] = true; HeaderBase::theHeaderInstances[Headers::RequestDisposition+1] = this; } ParserContainer<Token>& H_RequestDispositions::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_RequestDispositions::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::RequestDisposition); } H_RequestDispositions resip::h_RequestDispositions;
Headers::Type H_PMediaAuthorizations::getTypeNum() const {return Headers::PMediaAuthorization;} void H_PMediaAuthorizations::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_PMediaAuthorizations::H_PMediaAuthorizations() { Headers::CommaTokenizing[Headers::PMediaAuthorization+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::PMediaAuthorization+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::PMediaAuthorization+1] = "P-Media-Authorization"; Headers::Multi[Headers::PMediaAuthorization+1] = true; HeaderBase::theHeaderInstances[Headers::PMediaAuthorization+1] = this; } ParserContainer<Token>& H_PMediaAuthorizations::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<Token>*>(container); } ParserContainerBase* H_PMediaAuthorizations::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::PMediaAuthorization); } H_PMediaAuthorizations resip::h_PMediaAuthorizations;
Headers::Type H_Join::getTypeNum() const {return Headers::Join;} void H_Join::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_Join::H_Join() { Headers::CommaTokenizing[Headers::Join+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::Join+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::Join+1] = "Join"; Headers::Multi[Headers::Join+1] = false; HeaderBase::theHeaderInstances[Headers::Join+1] = this; } CallId& H_Join::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<CallId>*>(container)->front(); } ParserContainerBase* H_Join::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<CallId>(hfvs,Headers::Join); } H_Join resip::h_Join;
Headers::Type H_TargetDialog::getTypeNum() const {return Headers::TargetDialog;} void H_TargetDialog::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_TargetDialog::H_TargetDialog() { Headers::CommaTokenizing[Headers::TargetDialog+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::TargetDialog+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::TargetDialog+1] = "Target-Dialog"; Headers::Multi[Headers::TargetDialog+1] = false; HeaderBase::theHeaderInstances[Headers::TargetDialog+1] = this; } CallId& H_TargetDialog::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<CallId>*>(container)->front(); } ParserContainerBase* H_TargetDialog::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<CallId>(hfvs,Headers::TargetDialog); } H_TargetDialog resip::h_TargetDialog;
Headers::Type H_PAssertedIdentitys::getTypeNum() const {return Headers::PAssertedIdentity;} void H_PAssertedIdentitys::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_PAssertedIdentitys::H_PAssertedIdentitys() { Headers::CommaTokenizing[Headers::PAssertedIdentity+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::PAssertedIdentity+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::PAssertedIdentity+1] = "P-Asserted-Identity"; Headers::Multi[Headers::PAssertedIdentity+1] = true; HeaderBase::theHeaderInstances[Headers::PAssertedIdentity+1] = this; } ParserContainer<NameAddr>& H_PAssertedIdentitys::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<NameAddr>*>(container); } ParserContainerBase* H_PAssertedIdentitys::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::PAssertedIdentity); } H_PAssertedIdentitys resip::h_PAssertedIdentitys;
Headers::Type H_PPreferredIdentitys::getTypeNum() const {return Headers::PPreferredIdentity;} void H_PPreferredIdentitys::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_PPreferredIdentitys::H_PPreferredIdentitys() { Headers::CommaTokenizing[Headers::PPreferredIdentity+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::PPreferredIdentity+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::PPreferredIdentity+1] = "P-Preferred-Identity"; Headers::Multi[Headers::PPreferredIdentity+1] = true; HeaderBase::theHeaderInstances[Headers::PPreferredIdentity+1] = this; } ParserContainer<NameAddr>& H_PPreferredIdentitys::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<NameAddr>*>(container); } ParserContainerBase* H_PPreferredIdentitys::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::PPreferredIdentity); } H_PPreferredIdentitys resip::h_PPreferredIdentitys;
Headers::Type H_AcceptContacts::getTypeNum() const {return Headers::AcceptContact;} void H_AcceptContacts::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_AcceptContacts::H_AcceptContacts() { Headers::CommaTokenizing[Headers::AcceptContact+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::AcceptContact+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::AcceptContact+1] = "Accept-Contact"; Headers::Multi[Headers::AcceptContact+1] = true; HeaderBase::theHeaderInstances[Headers::AcceptContact+1] = this; } ParserContainer<NameAddr>& H_AcceptContacts::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<NameAddr>*>(container); } ParserContainerBase* H_AcceptContacts::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::AcceptContact); } H_AcceptContacts resip::h_AcceptContacts;
Headers::Type H_RejectContacts::getTypeNum() const {return Headers::RejectContact;} void H_RejectContacts::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_RejectContacts::H_RejectContacts() { Headers::CommaTokenizing[Headers::RejectContact+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::RejectContact+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::RejectContact+1] = "Reject-Contact"; Headers::Multi[Headers::RejectContact+1] = true; HeaderBase::theHeaderInstances[Headers::RejectContact+1] = this; } ParserContainer<NameAddr>& H_RejectContacts::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<NameAddr>*>(container); } ParserContainerBase* H_RejectContacts::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::RejectContact); } H_RejectContacts resip::h_RejectContacts;
Headers::Type H_PCalledPartyId::getTypeNum() const {return Headers::PCalledPartyId;} void H_PCalledPartyId::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_PCalledPartyId::H_PCalledPartyId() { Headers::CommaTokenizing[Headers::PCalledPartyId+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::PCalledPartyId+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::PCalledPartyId+1] = "P-Called-Party-ID"; Headers::Multi[Headers::PCalledPartyId+1] = false; HeaderBase::theHeaderInstances[Headers::PCalledPartyId+1] = this; } NameAddr& H_PCalledPartyId::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<NameAddr>*>(container)->front(); } ParserContainerBase* H_PCalledPartyId::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::PCalledPartyId); } H_PCalledPartyId resip::h_PCalledPartyId;
Headers::Type H_PAssociatedUris::getTypeNum() const {return Headers::PAssociatedUri;} void H_PAssociatedUris::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this).append(embedded.header(*this)); } } H_PAssociatedUris::H_PAssociatedUris() { Headers::CommaTokenizing[Headers::PAssociatedUri+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::PAssociatedUri+1] = bool(Type::value_type::commaHandling & 2); Headers::HeaderNames[Headers::PAssociatedUri+1] = "P-Associated-URI"; Headers::Multi[Headers::PAssociatedUri+1] = true; HeaderBase::theHeaderInstances[Headers::PAssociatedUri+1] = this; } ParserContainer<NameAddr>& H_PAssociatedUris::knownReturn(ParserContainerBase* container) { return *dynamic_cast<ParserContainer<NameAddr>*>(container); } ParserContainerBase* H_PAssociatedUris::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::PAssociatedUri); } H_PAssociatedUris resip::h_PAssociatedUris;
Headers::Type H_ContentLength::getTypeNum() const {return Headers::ContentLength;} void H_ContentLength::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_ContentLength::H_ContentLength() { Headers::CommaTokenizing[Headers::ContentLength+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ContentLength+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::ContentLength+1] = "Content-Length"; Headers::Multi[Headers::ContentLength+1] = false; HeaderBase::theHeaderInstances[Headers::ContentLength+1] = this; } UInt32Category& H_ContentLength::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<UInt32Category>*>(container)->front(); } ParserContainerBase* H_ContentLength::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<UInt32Category>(hfvs,Headers::ContentLength); } H_ContentLength resip::h_ContentLength;
Headers::Type H_ReferSub::getTypeNum() const {return Headers::ReferSub;} void H_ReferSub::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_ReferSub::H_ReferSub() { Headers::CommaTokenizing[Headers::ReferSub+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::ReferSub+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::ReferSub+1] = "Refer-Sub"; Headers::Multi[Headers::ReferSub+1] = false; HeaderBase::theHeaderInstances[Headers::ReferSub+1] = this; } Token& H_ReferSub::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_ReferSub::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::ReferSub); } H_ReferSub resip::h_ReferSub;
Headers::Type H_AnswerMode::getTypeNum() const {return Headers::AnswerMode;} void H_AnswerMode::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_AnswerMode::H_AnswerMode() { Headers::CommaTokenizing[Headers::AnswerMode+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::AnswerMode+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::AnswerMode+1] = "Answer-Mode"; Headers::Multi[Headers::AnswerMode+1] = false; HeaderBase::theHeaderInstances[Headers::AnswerMode+1] = this; } Token& H_AnswerMode::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_AnswerMode::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::AnswerMode); } H_AnswerMode resip::h_AnswerMode;
Headers::Type H_PrivAnswerMode::getTypeNum() const {return Headers::PrivAnswerMode;} void H_PrivAnswerMode::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_PrivAnswerMode::H_PrivAnswerMode() { Headers::CommaTokenizing[Headers::PrivAnswerMode+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::PrivAnswerMode+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::PrivAnswerMode+1] = "Priv-Answer-Mode"; Headers::Multi[Headers::PrivAnswerMode+1] = false; HeaderBase::theHeaderInstances[Headers::PrivAnswerMode+1] = this; } Token& H_PrivAnswerMode::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<Token>*>(container)->front(); } ParserContainerBase* H_PrivAnswerMode::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<Token>(hfvs,Headers::PrivAnswerMode); } H_PrivAnswerMode resip::h_PrivAnswerMode;
Headers::Type H_RemotePartyId::getTypeNum() const {return Headers::RemotePartyId;} void H_RemotePartyId::merge(SipMessage& target, const SipMessage& embedded) { if (embedded.exists(*this)) { target.header(*this) = embedded.header(*this); } } H_RemotePartyId::H_RemotePartyId() { Headers::CommaTokenizing[Headers::RemotePartyId+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti); Headers::CommaEncoding[Headers::RemotePartyId+1] = bool(Type::commaHandling & 2); Headers::HeaderNames[Headers::RemotePartyId+1] = "Remote-Party-ID"; Headers::Multi[Headers::RemotePartyId+1] = false; HeaderBase::theHeaderInstances[Headers::RemotePartyId+1] = this; } NameAddr& H_RemotePartyId::knownReturn(ParserContainerBase* container) { return dynamic_cast<ParserContainer<NameAddr>*>(container)->front(); } ParserContainerBase* H_RemotePartyId::makeContainer(HeaderFieldValueList* hfvs) const { return new ParserContainer<NameAddr>(hfvs,Headers::RemotePartyId); } H_RemotePartyId resip::h_RemotePartyId;
