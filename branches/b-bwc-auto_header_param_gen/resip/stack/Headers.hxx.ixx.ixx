// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know...
// Generated by updateHeaders.sh 







class H_Vias : public HeaderBase { public: RESIP_HeapCount(H_Vias); enum {Single = false}; typedef ParserContainer<Via> Type; MultiUnusedChecking(Via); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Vias(); }; extern H_Vias h_Vias;
class H_MaxForwards : public HeaderBase { public: RESIP_HeapCount(H_MaxForwards); enum {Single = true}; typedef UInt32Category Type; UnusedChecking(MaxForwards); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_MaxForwards(); }; extern H_MaxForwards h_MaxForwards;
class H_Routes : public HeaderBase { public: RESIP_HeapCount(H_Routes); enum {Single = false}; typedef ParserContainer<NameAddr> Type; MultiUnusedChecking(Route); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Routes(); }; extern H_Routes h_Routes;
class H_RecordRoutes : public HeaderBase { public: RESIP_HeapCount(H_RecordRoutes); enum {Single = false}; typedef ParserContainer<NameAddr> Type; MultiUnusedChecking(RecordRoute); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_RecordRoutes(); }; extern H_RecordRoutes h_RecordRoutes;
class H_Paths : public HeaderBase { public: RESIP_HeapCount(H_Paths); enum {Single = false}; typedef ParserContainer<NameAddr> Type; MultiUnusedChecking(Path); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Paths(); }; extern H_Paths h_Paths;
class H_ServiceRoutes : public HeaderBase { public: RESIP_HeapCount(H_ServiceRoutes); enum {Single = false}; typedef ParserContainer<NameAddr> Type; MultiUnusedChecking(ServiceRoute); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ServiceRoutes(); }; extern H_ServiceRoutes h_ServiceRoutes;
class H_ProxyRequires : public HeaderBase { public: RESIP_HeapCount(H_ProxyRequires); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(ProxyRequire); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ProxyRequires(); }; extern H_ProxyRequires h_ProxyRequires;
class H_ProxyAuthenticates : public HeaderBase { public: RESIP_HeapCount(H_ProxyAuthenticates); enum {Single = false}; typedef ParserContainer<Auth> Type; MultiUnusedChecking(ProxyAuthenticate); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ProxyAuthenticates(); }; extern H_ProxyAuthenticates h_ProxyAuthenticates;
class H_Identity : public HeaderBase { public: RESIP_HeapCount(H_Identity); enum {Single = true}; typedef StringCategory Type; UnusedChecking(Identity); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Identity(); }; extern H_Identity h_Identity;
class H_IdentityInfo : public HeaderBase { public: RESIP_HeapCount(H_IdentityInfo); enum {Single = true}; typedef GenericUri Type; UnusedChecking(IdentityInfo); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_IdentityInfo(); }; extern H_IdentityInfo h_IdentityInfo;
class H_Requires : public HeaderBase { public: RESIP_HeapCount(H_Requires); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(Require); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Requires(); }; extern H_Requires h_Requires;
class H_Contacts : public HeaderBase { public: RESIP_HeapCount(H_Contacts); enum {Single = false}; typedef ParserContainer<NameAddr> Type; MultiUnusedChecking(Contact); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Contacts(); }; extern H_Contacts h_Contacts;
class H_To : public HeaderBase { public: RESIP_HeapCount(H_To); enum {Single = true}; typedef NameAddr Type; UnusedChecking(To); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_To(); }; extern H_To h_To;
class H_From : public HeaderBase { public: RESIP_HeapCount(H_From); enum {Single = true}; typedef NameAddr Type; UnusedChecking(From); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_From(); }; extern H_From h_From;
class H_CallID : public HeaderBase { public: RESIP_HeapCount(H_CallID); enum {Single = true}; typedef CallId Type; UnusedChecking(CallID); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_CallID(); }; extern H_CallID h_CallID;
class H_CSeq : public HeaderBase { public: RESIP_HeapCount(H_CSeq); enum {Single = true}; typedef CSeqCategory Type; UnusedChecking(CSeq); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_CSeq(); }; extern H_CSeq h_CSeq;
class H_Subject : public HeaderBase { public: RESIP_HeapCount(H_Subject); enum {Single = true}; typedef StringCategory Type; UnusedChecking(Subject); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Subject(); }; extern H_Subject h_Subject;
class H_Expires : public HeaderBase { public: RESIP_HeapCount(H_Expires); enum {Single = true}; typedef ExpiresCategory Type; UnusedChecking(Expires); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Expires(); }; extern H_Expires h_Expires;
class H_SessionExpires : public HeaderBase { public: RESIP_HeapCount(H_SessionExpires); enum {Single = true}; typedef ExpiresCategory Type; UnusedChecking(SessionExpires); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_SessionExpires(); }; extern H_SessionExpires h_SessionExpires;
class H_MinSE : public HeaderBase { public: RESIP_HeapCount(H_MinSE); enum {Single = true}; typedef ExpiresCategory Type; UnusedChecking(MinSE); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_MinSE(); }; extern H_MinSE h_MinSE;
class H_Accepts : public HeaderBase { public: RESIP_HeapCount(H_Accepts); enum {Single = false}; typedef ParserContainer<Mime> Type; MultiUnusedChecking(Accept); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Accepts(); }; extern H_Accepts h_Accepts;
class H_AcceptEncodings : public HeaderBase { public: RESIP_HeapCount(H_AcceptEncodings); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(AcceptEncoding); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_AcceptEncodings(); }; extern H_AcceptEncodings h_AcceptEncodings;
class H_AcceptLanguages : public HeaderBase { public: RESIP_HeapCount(H_AcceptLanguages); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(AcceptLanguage); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_AcceptLanguages(); }; extern H_AcceptLanguages h_AcceptLanguages;
class H_AlertInfos : public HeaderBase { public: RESIP_HeapCount(H_AlertInfos); enum {Single = false}; typedef ParserContainer<GenericUri> Type; MultiUnusedChecking(AlertInfo); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_AlertInfos(); }; extern H_AlertInfos h_AlertInfos;
class H_Allows : public HeaderBase { public: RESIP_HeapCount(H_Allows); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(Allow); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Allows(); }; extern H_Allows h_Allows;
class H_AuthenticationInfo : public HeaderBase { public: RESIP_HeapCount(H_AuthenticationInfo); enum {Single = true}; typedef Auth Type; UnusedChecking(AuthenticationInfo); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_AuthenticationInfo(); }; extern H_AuthenticationInfo h_AuthenticationInfo;
class H_CallInfos : public HeaderBase { public: RESIP_HeapCount(H_CallInfos); enum {Single = false}; typedef ParserContainer<GenericUri> Type; MultiUnusedChecking(CallInfo); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_CallInfos(); }; extern H_CallInfos h_CallInfos;
class H_ContentDisposition : public HeaderBase { public: RESIP_HeapCount(H_ContentDisposition); enum {Single = true}; typedef Token Type; UnusedChecking(ContentDisposition); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ContentDisposition(); }; extern H_ContentDisposition h_ContentDisposition;
class H_ContentEncoding : public HeaderBase { public: RESIP_HeapCount(H_ContentEncoding); enum {Single = true}; typedef Token Type; UnusedChecking(ContentEncoding); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ContentEncoding(); }; extern H_ContentEncoding h_ContentEncoding;
class H_ContentId : public HeaderBase { public: RESIP_HeapCount(H_ContentId); enum {Single = true}; typedef Token Type; UnusedChecking(ContentId); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ContentId(); }; extern H_ContentId h_ContentId;
class H_ContentLanguages : public HeaderBase { public: RESIP_HeapCount(H_ContentLanguages); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(ContentLanguage); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ContentLanguages(); }; extern H_ContentLanguages h_ContentLanguages;
class H_ContentTransferEncoding : public HeaderBase { public: RESIP_HeapCount(H_ContentTransferEncoding); enum {Single = true}; typedef StringCategory Type; UnusedChecking(ContentTransferEncoding); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ContentTransferEncoding(); }; extern H_ContentTransferEncoding h_ContentTransferEncoding;
class H_ContentType : public HeaderBase { public: RESIP_HeapCount(H_ContentType); enum {Single = true}; typedef Mime Type; UnusedChecking(ContentType); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ContentType(); }; extern H_ContentType h_ContentType;
class H_Date : public HeaderBase { public: RESIP_HeapCount(H_Date); enum {Single = true}; typedef DateCategory Type; UnusedChecking(Date); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Date(); }; extern H_Date h_Date;
class H_ErrorInfos : public HeaderBase { public: RESIP_HeapCount(H_ErrorInfos); enum {Single = false}; typedef ParserContainer<GenericUri> Type; MultiUnusedChecking(ErrorInfo); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ErrorInfos(); }; extern H_ErrorInfos h_ErrorInfos;
class H_InReplyTo : public HeaderBase { public: RESIP_HeapCount(H_InReplyTo); enum {Single = true}; typedef CallId Type; UnusedChecking(InReplyTo); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_InReplyTo(); }; extern H_InReplyTo h_InReplyTo;
class H_MinExpires : public HeaderBase { public: RESIP_HeapCount(H_MinExpires); enum {Single = true}; typedef UInt32Category Type; UnusedChecking(MinExpires); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_MinExpires(); }; extern H_MinExpires h_MinExpires;
class H_MIMEVersion : public HeaderBase { public: RESIP_HeapCount(H_MIMEVersion); enum {Single = true}; typedef Token Type; UnusedChecking(MIMEVersion); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_MIMEVersion(); }; extern H_MIMEVersion h_MIMEVersion;
class H_Organization : public HeaderBase { public: RESIP_HeapCount(H_Organization); enum {Single = true}; typedef StringCategory Type; UnusedChecking(Organization); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Organization(); }; extern H_Organization h_Organization;
class H_Priority : public HeaderBase { public: RESIP_HeapCount(H_Priority); enum {Single = true}; typedef Token Type; UnusedChecking(Priority); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Priority(); }; extern H_Priority h_Priority;
class H_ProxyAuthorizations : public HeaderBase { public: RESIP_HeapCount(H_ProxyAuthorizations); enum {Single = false}; typedef ParserContainer<Auth> Type; MultiUnusedChecking(ProxyAuthorization); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ProxyAuthorizations(); }; extern H_ProxyAuthorizations h_ProxyAuthorizations;
class H_ReplyTo : public HeaderBase { public: RESIP_HeapCount(H_ReplyTo); enum {Single = true}; typedef NameAddr Type; UnusedChecking(ReplyTo); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ReplyTo(); }; extern H_ReplyTo h_ReplyTo;
class H_RetryAfter : public HeaderBase { public: RESIP_HeapCount(H_RetryAfter); enum {Single = true}; typedef UInt32Category Type; UnusedChecking(RetryAfter); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_RetryAfter(); }; extern H_RetryAfter h_RetryAfter;
class H_Server : public HeaderBase { public: RESIP_HeapCount(H_Server); enum {Single = true}; typedef StringCategory Type; UnusedChecking(Server); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Server(); }; extern H_Server h_Server;
class H_SIPETag : public HeaderBase { public: RESIP_HeapCount(H_SIPETag); enum {Single = true}; typedef Token Type; UnusedChecking(SIPETag); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_SIPETag(); }; extern H_SIPETag h_SIPETag;
class H_SIPIfMatch : public HeaderBase { public: RESIP_HeapCount(H_SIPIfMatch); enum {Single = true}; typedef Token Type; UnusedChecking(SIPIfMatch); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_SIPIfMatch(); }; extern H_SIPIfMatch h_SIPIfMatch;
class H_Supporteds : public HeaderBase { public: RESIP_HeapCount(H_Supporteds); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(Supported); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Supporteds(); }; extern H_Supporteds h_Supporteds;
class H_Timestamp : public HeaderBase { public: RESIP_HeapCount(H_Timestamp); enum {Single = true}; typedef StringCategory Type; UnusedChecking(Timestamp); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Timestamp(); }; extern H_Timestamp h_Timestamp;
class H_Unsupporteds : public HeaderBase { public: RESIP_HeapCount(H_Unsupporteds); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(Unsupported); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Unsupporteds(); }; extern H_Unsupporteds h_Unsupporteds;
class H_UserAgent : public HeaderBase { public: RESIP_HeapCount(H_UserAgent); enum {Single = true}; typedef StringCategory Type; UnusedChecking(UserAgent); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_UserAgent(); }; extern H_UserAgent h_UserAgent;
class H_Warnings : public HeaderBase { public: RESIP_HeapCount(H_Warnings); enum {Single = false}; typedef ParserContainer<WarningCategory> Type; MultiUnusedChecking(Warning); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Warnings(); }; extern H_Warnings h_Warnings;
class H_WWWAuthenticates : public HeaderBase { public: RESIP_HeapCount(H_WWWAuthenticates); enum {Single = false}; typedef ParserContainer<Auth> Type; MultiUnusedChecking(WWWAuthenticate); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_WWWAuthenticates(); }; extern H_WWWAuthenticates h_WWWAuthenticates;
class H_SubscriptionState : public HeaderBase { public: RESIP_HeapCount(H_SubscriptionState); enum {Single = true}; typedef Token Type; UnusedChecking(SubscriptionState); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_SubscriptionState(); }; extern H_SubscriptionState h_SubscriptionState;
class H_ReferTo : public HeaderBase { public: RESIP_HeapCount(H_ReferTo); enum {Single = true}; typedef NameAddr Type; UnusedChecking(ReferTo); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ReferTo(); }; extern H_ReferTo h_ReferTo;
class H_ReferredBy : public HeaderBase { public: RESIP_HeapCount(H_ReferredBy); enum {Single = true}; typedef NameAddr Type; UnusedChecking(ReferredBy); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ReferredBy(); }; extern H_ReferredBy h_ReferredBy;
class H_Authorizations : public HeaderBase { public: RESIP_HeapCount(H_Authorizations); enum {Single = false}; typedef ParserContainer<Auth> Type; MultiUnusedChecking(Authorization); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Authorizations(); }; extern H_Authorizations h_Authorizations;
class H_Replaces : public HeaderBase { public: RESIP_HeapCount(H_Replaces); enum {Single = true}; typedef CallId Type; UnusedChecking(Replaces); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Replaces(); }; extern H_Replaces h_Replaces;
class H_Event : public HeaderBase { public: RESIP_HeapCount(H_Event); enum {Single = true}; typedef Token Type; UnusedChecking(Event); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Event(); }; extern H_Event h_Event;
class H_AllowEventss : public HeaderBase { public: RESIP_HeapCount(H_AllowEventss); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(AllowEvents); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_AllowEventss(); }; extern H_AllowEventss h_AllowEventss;
class H_SecurityClients : public HeaderBase { public: RESIP_HeapCount(H_SecurityClients); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(SecurityClient); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_SecurityClients(); }; extern H_SecurityClients h_SecurityClients;
class H_SecurityServers : public HeaderBase { public: RESIP_HeapCount(H_SecurityServers); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(SecurityServer); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_SecurityServers(); }; extern H_SecurityServers h_SecurityServers;
class H_SecurityVerifys : public HeaderBase { public: RESIP_HeapCount(H_SecurityVerifys); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(SecurityVerify); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_SecurityVerifys(); }; extern H_SecurityVerifys h_SecurityVerifys;
class H_RSeq : public HeaderBase { public: RESIP_HeapCount(H_RSeq); enum {Single = true}; typedef UInt32Category Type; UnusedChecking(RSeq); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_RSeq(); }; extern H_RSeq h_RSeq;
class H_RAck : public HeaderBase { public: RESIP_HeapCount(H_RAck); enum {Single = true}; typedef RAckCategory Type; UnusedChecking(RAck); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_RAck(); }; extern H_RAck h_RAck;
class H_Reasons : public HeaderBase { public: RESIP_HeapCount(H_Reasons); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(Reason); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Reasons(); }; extern H_Reasons h_Reasons;
class H_Privacys : public HeaderBase { public: RESIP_HeapCount(H_Privacys); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(Privacy); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Privacys(); }; extern H_Privacys h_Privacys;
class H_RequestDispositions : public HeaderBase { public: RESIP_HeapCount(H_RequestDispositions); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(RequestDisposition); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_RequestDispositions(); }; extern H_RequestDispositions h_RequestDispositions;
class H_PMediaAuthorizations : public HeaderBase { public: RESIP_HeapCount(H_PMediaAuthorizations); enum {Single = false}; typedef ParserContainer<Token> Type; MultiUnusedChecking(PMediaAuthorization); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_PMediaAuthorizations(); }; extern H_PMediaAuthorizations h_PMediaAuthorizations;
class H_Join : public HeaderBase { public: RESIP_HeapCount(H_Join); enum {Single = true}; typedef CallId Type; UnusedChecking(Join); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_Join(); }; extern H_Join h_Join;
class H_TargetDialog : public HeaderBase { public: RESIP_HeapCount(H_TargetDialog); enum {Single = true}; typedef CallId Type; UnusedChecking(TargetDialog); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_TargetDialog(); }; extern H_TargetDialog h_TargetDialog;
class H_PAssertedIdentitys : public HeaderBase { public: RESIP_HeapCount(H_PAssertedIdentitys); enum {Single = false}; typedef ParserContainer<NameAddr> Type; MultiUnusedChecking(PAssertedIdentity); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_PAssertedIdentitys(); }; extern H_PAssertedIdentitys h_PAssertedIdentitys;
class H_PPreferredIdentitys : public HeaderBase { public: RESIP_HeapCount(H_PPreferredIdentitys); enum {Single = false}; typedef ParserContainer<NameAddr> Type; MultiUnusedChecking(PPreferredIdentity); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_PPreferredIdentitys(); }; extern H_PPreferredIdentitys h_PPreferredIdentitys;
class H_AcceptContacts : public HeaderBase { public: RESIP_HeapCount(H_AcceptContacts); enum {Single = false}; typedef ParserContainer<NameAddr> Type; MultiUnusedChecking(AcceptContact); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_AcceptContacts(); }; extern H_AcceptContacts h_AcceptContacts;
class H_RejectContacts : public HeaderBase { public: RESIP_HeapCount(H_RejectContacts); enum {Single = false}; typedef ParserContainer<NameAddr> Type; MultiUnusedChecking(RejectContact); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_RejectContacts(); }; extern H_RejectContacts h_RejectContacts;
class H_PCalledPartyId : public HeaderBase { public: RESIP_HeapCount(H_PCalledPartyId); enum {Single = true}; typedef NameAddr Type; UnusedChecking(PCalledPartyId); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_PCalledPartyId(); }; extern H_PCalledPartyId h_PCalledPartyId;
class H_PAssociatedUris : public HeaderBase { public: RESIP_HeapCount(H_PAssociatedUris); enum {Single = false}; typedef ParserContainer<NameAddr> Type; MultiUnusedChecking(PAssociatedUri); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_PAssociatedUris(); }; extern H_PAssociatedUris h_PAssociatedUris;
class H_ContentLength : public HeaderBase { public: RESIP_HeapCount(H_ContentLength); enum {Single = true}; typedef UInt32Category Type; UnusedChecking(ContentLength); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ContentLength(); }; extern H_ContentLength h_ContentLength;
class H_ReferSub : public HeaderBase { public: RESIP_HeapCount(H_ReferSub); enum {Single = true}; typedef Token Type; UnusedChecking(ReferSub); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_ReferSub(); }; extern H_ReferSub h_ReferSub;
class H_AnswerMode : public HeaderBase { public: RESIP_HeapCount(H_AnswerMode); enum {Single = true}; typedef Token Type; UnusedChecking(AnswerMode); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_AnswerMode(); }; extern H_AnswerMode h_AnswerMode;
class H_PrivAnswerMode : public HeaderBase { public: RESIP_HeapCount(H_PrivAnswerMode); enum {Single = true}; typedef Token Type; UnusedChecking(PrivAnswerMode); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_PrivAnswerMode(); }; extern H_PrivAnswerMode h_PrivAnswerMode;
class H_RemotePartyId : public HeaderBase { public: RESIP_HeapCount(H_RemotePartyId); enum {Single = true}; typedef NameAddr Type; UnusedChecking(RemotePartyId); static Type& knownReturn(ParserContainerBase* container); virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const; virtual Headers::Type getTypeNum() const; virtual void merge(SipMessage&, const SipMessage&); H_RemotePartyId(); }; extern H_RemotePartyId h_RemotePartyId;
