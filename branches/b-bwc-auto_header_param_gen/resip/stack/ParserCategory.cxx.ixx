// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know...
// Generated by updateParameters.sh 





data_Param::DType& ParserCategory::param(const data_Param& paramType) { checkParsed(); data_Param::Type* p = static_cast<data_Param::Type*>(getParameterByEnum(ParameterTypes::data)); if (!p) { p = new data_Param::Type(ParameterTypes::data); mParameters.push_back(p); } return p->value(); } const data_Param::DType& ParserCategory::param(const data_Param& paramType) const { checkParsed(); data_Param::Type* p = static_cast<data_Param::Type*>(getParameterByEnum(ParameterTypes::data)); if (!p) { InfoLog(<< "Missing parameter " "data" ); DebugLog(<< *this); throw Exception("Missing parameter " "data", "ParserCategory.cxx.ixx.temp", 40); } return p->value(); };
control_Param::DType& ParserCategory::param(const control_Param& paramType) { checkParsed(); control_Param::Type* p = static_cast<control_Param::Type*>(getParameterByEnum(ParameterTypes::control)); if (!p) { p = new control_Param::Type(ParameterTypes::control); mParameters.push_back(p); } return p->value(); } const control_Param::DType& ParserCategory::param(const control_Param& paramType) const { checkParsed(); control_Param::Type* p = static_cast<control_Param::Type*>(getParameterByEnum(ParameterTypes::control)); if (!p) { InfoLog(<< "Missing parameter " "control" ); DebugLog(<< *this); throw Exception("Missing parameter " "control", "ParserCategory.cxx.ixx.temp", 41); } return p->value(); };
mobility_Param::DType& ParserCategory::param(const mobility_Param& paramType) { checkParsed(); mobility_Param::Type* p = static_cast<mobility_Param::Type*>(getParameterByEnum(ParameterTypes::mobility)); if (!p) { p = new mobility_Param::Type(ParameterTypes::mobility); mParameters.push_back(p); } return p->value(); } const mobility_Param::DType& ParserCategory::param(const mobility_Param& paramType) const { checkParsed(); mobility_Param::Type* p = static_cast<mobility_Param::Type*>(getParameterByEnum(ParameterTypes::mobility)); if (!p) { InfoLog(<< "Missing parameter " "mobility" ); DebugLog(<< *this); throw Exception("Missing parameter " "mobility", "ParserCategory.cxx.ixx.temp", 42); } return p->value(); };
description_Param::DType& ParserCategory::param(const description_Param& paramType) { checkParsed(); description_Param::Type* p = static_cast<description_Param::Type*>(getParameterByEnum(ParameterTypes::description)); if (!p) { p = new description_Param::Type(ParameterTypes::description); mParameters.push_back(p); } return p->value(); } const description_Param::DType& ParserCategory::param(const description_Param& paramType) const { checkParsed(); description_Param::Type* p = static_cast<description_Param::Type*>(getParameterByEnum(ParameterTypes::description)); if (!p) { InfoLog(<< "Missing parameter " "description" ); DebugLog(<< *this); throw Exception("Missing parameter " "description", "ParserCategory.cxx.ixx.temp", 43); } return p->value(); };
events_Param::DType& ParserCategory::param(const events_Param& paramType) { checkParsed(); events_Param::Type* p = static_cast<events_Param::Type*>(getParameterByEnum(ParameterTypes::events)); if (!p) { p = new events_Param::Type(ParameterTypes::events); mParameters.push_back(p); } return p->value(); } const events_Param::DType& ParserCategory::param(const events_Param& paramType) const { checkParsed(); events_Param::Type* p = static_cast<events_Param::Type*>(getParameterByEnum(ParameterTypes::events)); if (!p) { InfoLog(<< "Missing parameter " "events" ); DebugLog(<< *this); throw Exception("Missing parameter " "events", "ParserCategory.cxx.ixx.temp", 44); } return p->value(); };
priority_Param::DType& ParserCategory::param(const priority_Param& paramType) { checkParsed(); priority_Param::Type* p = static_cast<priority_Param::Type*>(getParameterByEnum(ParameterTypes::priority)); if (!p) { p = new priority_Param::Type(ParameterTypes::priority); mParameters.push_back(p); } return p->value(); } const priority_Param::DType& ParserCategory::param(const priority_Param& paramType) const { checkParsed(); priority_Param::Type* p = static_cast<priority_Param::Type*>(getParameterByEnum(ParameterTypes::priority)); if (!p) { InfoLog(<< "Missing parameter " "priority" ); DebugLog(<< *this); throw Exception("Missing parameter " "priority", "ParserCategory.cxx.ixx.temp", 45); } return p->value(); };
methods_Param::DType& ParserCategory::param(const methods_Param& paramType) { checkParsed(); methods_Param::Type* p = static_cast<methods_Param::Type*>(getParameterByEnum(ParameterTypes::methods)); if (!p) { p = new methods_Param::Type(ParameterTypes::methods); mParameters.push_back(p); } return p->value(); } const methods_Param::DType& ParserCategory::param(const methods_Param& paramType) const { checkParsed(); methods_Param::Type* p = static_cast<methods_Param::Type*>(getParameterByEnum(ParameterTypes::methods)); if (!p) { InfoLog(<< "Missing parameter " "methods" ); DebugLog(<< *this); throw Exception("Missing parameter " "methods", "ParserCategory.cxx.ixx.temp", 46); } return p->value(); };
schemes_Param::DType& ParserCategory::param(const schemes_Param& paramType) { checkParsed(); schemes_Param::Type* p = static_cast<schemes_Param::Type*>(getParameterByEnum(ParameterTypes::schemes)); if (!p) { p = new schemes_Param::Type(ParameterTypes::schemes); mParameters.push_back(p); } return p->value(); } const schemes_Param::DType& ParserCategory::param(const schemes_Param& paramType) const { checkParsed(); schemes_Param::Type* p = static_cast<schemes_Param::Type*>(getParameterByEnum(ParameterTypes::schemes)); if (!p) { InfoLog(<< "Missing parameter " "schemes" ); DebugLog(<< *this); throw Exception("Missing parameter " "schemes", "ParserCategory.cxx.ixx.temp", 47); } return p->value(); };
application_Param::DType& ParserCategory::param(const application_Param& paramType) { checkParsed(); application_Param::Type* p = static_cast<application_Param::Type*>(getParameterByEnum(ParameterTypes::application)); if (!p) { p = new application_Param::Type(ParameterTypes::application); mParameters.push_back(p); } return p->value(); } const application_Param::DType& ParserCategory::param(const application_Param& paramType) const { checkParsed(); application_Param::Type* p = static_cast<application_Param::Type*>(getParameterByEnum(ParameterTypes::application)); if (!p) { InfoLog(<< "Missing parameter " "application" ); DebugLog(<< *this); throw Exception("Missing parameter " "application", "ParserCategory.cxx.ixx.temp", 48); } return p->value(); };
video_Param::DType& ParserCategory::param(const video_Param& paramType) { checkParsed(); video_Param::Type* p = static_cast<video_Param::Type*>(getParameterByEnum(ParameterTypes::video)); if (!p) { p = new video_Param::Type(ParameterTypes::video); mParameters.push_back(p); } return p->value(); } const video_Param::DType& ParserCategory::param(const video_Param& paramType) const { checkParsed(); video_Param::Type* p = static_cast<video_Param::Type*>(getParameterByEnum(ParameterTypes::video)); if (!p) { InfoLog(<< "Missing parameter " "video" ); DebugLog(<< *this); throw Exception("Missing parameter " "video", "ParserCategory.cxx.ixx.temp", 49); } return p->value(); };
language_Param::DType& ParserCategory::param(const language_Param& paramType) { checkParsed(); language_Param::Type* p = static_cast<language_Param::Type*>(getParameterByEnum(ParameterTypes::language)); if (!p) { p = new language_Param::Type(ParameterTypes::language); mParameters.push_back(p); } return p->value(); } const language_Param::DType& ParserCategory::param(const language_Param& paramType) const { checkParsed(); language_Param::Type* p = static_cast<language_Param::Type*>(getParameterByEnum(ParameterTypes::language)); if (!p) { InfoLog(<< "Missing parameter " "language" ); DebugLog(<< *this); throw Exception("Missing parameter " "language", "ParserCategory.cxx.ixx.temp", 50); } return p->value(); };
type_Param::DType& ParserCategory::param(const type_Param& paramType) { checkParsed(); type_Param::Type* p = static_cast<type_Param::Type*>(getParameterByEnum(ParameterTypes::type)); if (!p) { p = new type_Param::Type(ParameterTypes::type); mParameters.push_back(p); } return p->value(); } const type_Param::DType& ParserCategory::param(const type_Param& paramType) const { checkParsed(); type_Param::Type* p = static_cast<type_Param::Type*>(getParameterByEnum(ParameterTypes::type)); if (!p) { InfoLog(<< "Missing parameter " "type" ); DebugLog(<< *this); throw Exception("Missing parameter " "type", "ParserCategory.cxx.ixx.temp", 51); } return p->value(); };
isFocus_Param::DType& ParserCategory::param(const isFocus_Param& paramType) { checkParsed(); isFocus_Param::Type* p = static_cast<isFocus_Param::Type*>(getParameterByEnum(ParameterTypes::isFocus)); if (!p) { p = new isFocus_Param::Type(ParameterTypes::isFocus); mParameters.push_back(p); } return p->value(); } const isFocus_Param::DType& ParserCategory::param(const isFocus_Param& paramType) const { checkParsed(); isFocus_Param::Type* p = static_cast<isFocus_Param::Type*>(getParameterByEnum(ParameterTypes::isFocus)); if (!p) { InfoLog(<< "Missing parameter " "isfocus" ); DebugLog(<< *this); throw Exception("Missing parameter " "isfocus", "ParserCategory.cxx.ixx.temp", 52); } return p->value(); };
actor_Param::DType& ParserCategory::param(const actor_Param& paramType) { checkParsed(); actor_Param::Type* p = static_cast<actor_Param::Type*>(getParameterByEnum(ParameterTypes::actor)); if (!p) { p = new actor_Param::Type(ParameterTypes::actor); mParameters.push_back(p); } return p->value(); } const actor_Param::DType& ParserCategory::param(const actor_Param& paramType) const { checkParsed(); actor_Param::Type* p = static_cast<actor_Param::Type*>(getParameterByEnum(ParameterTypes::actor)); if (!p) { InfoLog(<< "Missing parameter " "actor" ); DebugLog(<< *this); throw Exception("Missing parameter " "actor", "ParserCategory.cxx.ixx.temp", 53); } return p->value(); };
text_Param::DType& ParserCategory::param(const text_Param& paramType) { checkParsed(); text_Param::Type* p = static_cast<text_Param::Type*>(getParameterByEnum(ParameterTypes::text)); if (!p) { p = new text_Param::Type(ParameterTypes::text); mParameters.push_back(p); } return p->value(); } const text_Param::DType& ParserCategory::param(const text_Param& paramType) const { checkParsed(); text_Param::Type* p = static_cast<text_Param::Type*>(getParameterByEnum(ParameterTypes::text)); if (!p) { InfoLog(<< "Missing parameter " "text" ); DebugLog(<< *this); throw Exception("Missing parameter " "text", "ParserCategory.cxx.ixx.temp", 54); } return p->value(); };
extensions_Param::DType& ParserCategory::param(const extensions_Param& paramType) { checkParsed(); extensions_Param::Type* p = static_cast<extensions_Param::Type*>(getParameterByEnum(ParameterTypes::extensions)); if (!p) { p = new extensions_Param::Type(ParameterTypes::extensions); mParameters.push_back(p); } return p->value(); } const extensions_Param::DType& ParserCategory::param(const extensions_Param& paramType) const { checkParsed(); extensions_Param::Type* p = static_cast<extensions_Param::Type*>(getParameterByEnum(ParameterTypes::extensions)); if (!p) { InfoLog(<< "Missing parameter " "extensions" ); DebugLog(<< *this); throw Exception("Missing parameter " "extensions", "ParserCategory.cxx.ixx.temp", 55); } return p->value(); };
Instance_Param::DType& ParserCategory::param(const Instance_Param& paramType) { checkParsed(); Instance_Param::Type* p = static_cast<Instance_Param::Type*>(getParameterByEnum(ParameterTypes::Instance)); if (!p) { p = new Instance_Param::Type(ParameterTypes::Instance); mParameters.push_back(p); } return p->value(); } const Instance_Param::DType& ParserCategory::param(const Instance_Param& paramType) const { checkParsed(); Instance_Param::Type* p = static_cast<Instance_Param::Type*>(getParameterByEnum(ParameterTypes::Instance)); if (!p) { InfoLog(<< "Missing parameter " "+sip.instance" ); DebugLog(<< *this); throw Exception("Missing parameter " "+sip.instance", "ParserCategory.cxx.ixx.temp", 56); } return p->value(); };
regid_Param::DType& ParserCategory::param(const regid_Param& paramType) { checkParsed(); regid_Param::Type* p = static_cast<regid_Param::Type*>(getParameterByEnum(ParameterTypes::regid)); if (!p) { p = new regid_Param::Type(ParameterTypes::regid); mParameters.push_back(p); } return p->value(); } const regid_Param::DType& ParserCategory::param(const regid_Param& paramType) const { checkParsed(); regid_Param::Type* p = static_cast<regid_Param::Type*>(getParameterByEnum(ParameterTypes::regid)); if (!p) { InfoLog(<< "Missing parameter " "reg-id" ); DebugLog(<< *this); throw Exception("Missing parameter " "reg-id", "ParserCategory.cxx.ixx.temp", 57); } return p->value(); };
ob_Param::DType& ParserCategory::param(const ob_Param& paramType) { checkParsed(); ob_Param::Type* p = static_cast<ob_Param::Type*>(getParameterByEnum(ParameterTypes::ob)); if (!p) { p = new ob_Param::Type(ParameterTypes::ob); mParameters.push_back(p); } return p->value(); } const ob_Param::DType& ParserCategory::param(const ob_Param& paramType) const { checkParsed(); ob_Param::Type* p = static_cast<ob_Param::Type*>(getParameterByEnum(ParameterTypes::ob)); if (!p) { InfoLog(<< "Missing parameter " "ob" ); DebugLog(<< *this); throw Exception("Missing parameter " "ob", "ParserCategory.cxx.ixx.temp", 58); } return p->value(); };
pubGruu_Param::DType& ParserCategory::param(const pubGruu_Param& paramType) { checkParsed(); pubGruu_Param::Type* p = static_cast<pubGruu_Param::Type*>(getParameterByEnum(ParameterTypes::pubGruu)); if (!p) { p = new pubGruu_Param::Type(ParameterTypes::pubGruu); mParameters.push_back(p); } return p->value(); } const pubGruu_Param::DType& ParserCategory::param(const pubGruu_Param& paramType) const { checkParsed(); pubGruu_Param::Type* p = static_cast<pubGruu_Param::Type*>(getParameterByEnum(ParameterTypes::pubGruu)); if (!p) { InfoLog(<< "Missing parameter " "pub-gruu" ); DebugLog(<< *this); throw Exception("Missing parameter " "pub-gruu", "ParserCategory.cxx.ixx.temp", 59); } return p->value(); };
tempGruu_Param::DType& ParserCategory::param(const tempGruu_Param& paramType) { checkParsed(); tempGruu_Param::Type* p = static_cast<tempGruu_Param::Type*>(getParameterByEnum(ParameterTypes::tempGruu)); if (!p) { p = new tempGruu_Param::Type(ParameterTypes::tempGruu); mParameters.push_back(p); } return p->value(); } const tempGruu_Param::DType& ParserCategory::param(const tempGruu_Param& paramType) const { checkParsed(); tempGruu_Param::Type* p = static_cast<tempGruu_Param::Type*>(getParameterByEnum(ParameterTypes::tempGruu)); if (!p) { InfoLog(<< "Missing parameter " "temp-gruu" ); DebugLog(<< *this); throw Exception("Missing parameter " "temp-gruu", "ParserCategory.cxx.ixx.temp", 60); } return p->value(); };
gruu_Param::DType& ParserCategory::param(const gruu_Param& paramType) { checkParsed(); gruu_Param::Type* p = static_cast<gruu_Param::Type*>(getParameterByEnum(ParameterTypes::gruu)); if (!p) { p = new gruu_Param::Type(ParameterTypes::gruu); mParameters.push_back(p); } return p->value(); } const gruu_Param::DType& ParserCategory::param(const gruu_Param& paramType) const { checkParsed(); gruu_Param::Type* p = static_cast<gruu_Param::Type*>(getParameterByEnum(ParameterTypes::gruu)); if (!p) { InfoLog(<< "Missing parameter " "gruu" ); DebugLog(<< *this); throw Exception("Missing parameter " "gruu", "ParserCategory.cxx.ixx.temp", 61); } return p->value(); };
accessType_Param::DType& ParserCategory::param(const accessType_Param& paramType) { checkParsed(); accessType_Param::Type* p = static_cast<accessType_Param::Type*>(getParameterByEnum(ParameterTypes::accessType)); if (!p) { p = new accessType_Param::Type(ParameterTypes::accessType); mParameters.push_back(p); } return p->value(); } const accessType_Param::DType& ParserCategory::param(const accessType_Param& paramType) const { checkParsed(); accessType_Param::Type* p = static_cast<accessType_Param::Type*>(getParameterByEnum(ParameterTypes::accessType)); if (!p) { InfoLog(<< "Missing parameter " "access-type" ); DebugLog(<< *this); throw Exception("Missing parameter " "access-type", "ParserCategory.cxx.ixx.temp", 62); } return p->value(); };
algorithm_Param::DType& ParserCategory::param(const algorithm_Param& paramType) { checkParsed(); algorithm_Param::Type* p = static_cast<algorithm_Param::Type*>(getParameterByEnum(ParameterTypes::algorithm)); if (!p) { p = new algorithm_Param::Type(ParameterTypes::algorithm); mParameters.push_back(p); } return p->value(); } const algorithm_Param::DType& ParserCategory::param(const algorithm_Param& paramType) const { checkParsed(); algorithm_Param::Type* p = static_cast<algorithm_Param::Type*>(getParameterByEnum(ParameterTypes::algorithm)); if (!p) { InfoLog(<< "Missing parameter " "algorithm" ); DebugLog(<< *this); throw Exception("Missing parameter " "algorithm", "ParserCategory.cxx.ixx.temp", 63); } return p->value(); };
boundary_Param::DType& ParserCategory::param(const boundary_Param& paramType) { checkParsed(); boundary_Param::Type* p = static_cast<boundary_Param::Type*>(getParameterByEnum(ParameterTypes::boundary)); if (!p) { p = new boundary_Param::Type(ParameterTypes::boundary); mParameters.push_back(p); } return p->value(); } const boundary_Param::DType& ParserCategory::param(const boundary_Param& paramType) const { checkParsed(); boundary_Param::Type* p = static_cast<boundary_Param::Type*>(getParameterByEnum(ParameterTypes::boundary)); if (!p) { InfoLog(<< "Missing parameter " "boundary" ); DebugLog(<< *this); throw Exception("Missing parameter " "boundary", "ParserCategory.cxx.ixx.temp", 64); } return p->value(); };
branch_Param::DType& ParserCategory::param(const branch_Param& paramType) { checkParsed(); branch_Param::Type* p = static_cast<branch_Param::Type*>(getParameterByEnum(ParameterTypes::branch)); if (!p) { p = new branch_Param::Type(ParameterTypes::branch); mParameters.push_back(p); } return p->value(); } const branch_Param::DType& ParserCategory::param(const branch_Param& paramType) const { checkParsed(); branch_Param::Type* p = static_cast<branch_Param::Type*>(getParameterByEnum(ParameterTypes::branch)); if (!p) { InfoLog(<< "Missing parameter " "branch" ); DebugLog(<< *this); throw Exception("Missing parameter " "branch", "ParserCategory.cxx.ixx.temp", 65); } return p->value(); };
charset_Param::DType& ParserCategory::param(const charset_Param& paramType) { checkParsed(); charset_Param::Type* p = static_cast<charset_Param::Type*>(getParameterByEnum(ParameterTypes::charset)); if (!p) { p = new charset_Param::Type(ParameterTypes::charset); mParameters.push_back(p); } return p->value(); } const charset_Param::DType& ParserCategory::param(const charset_Param& paramType) const { checkParsed(); charset_Param::Type* p = static_cast<charset_Param::Type*>(getParameterByEnum(ParameterTypes::charset)); if (!p) { InfoLog(<< "Missing parameter " "charset" ); DebugLog(<< *this); throw Exception("Missing parameter " "charset", "ParserCategory.cxx.ixx.temp", 66); } return p->value(); };
cnonce_Param::DType& ParserCategory::param(const cnonce_Param& paramType) { checkParsed(); cnonce_Param::Type* p = static_cast<cnonce_Param::Type*>(getParameterByEnum(ParameterTypes::cnonce)); if (!p) { p = new cnonce_Param::Type(ParameterTypes::cnonce); mParameters.push_back(p); } return p->value(); } const cnonce_Param::DType& ParserCategory::param(const cnonce_Param& paramType) const { checkParsed(); cnonce_Param::Type* p = static_cast<cnonce_Param::Type*>(getParameterByEnum(ParameterTypes::cnonce)); if (!p) { InfoLog(<< "Missing parameter " "cnonce" ); DebugLog(<< *this); throw Exception("Missing parameter " "cnonce", "ParserCategory.cxx.ixx.temp", 67); } return p->value(); };
comp_Param::DType& ParserCategory::param(const comp_Param& paramType) { checkParsed(); comp_Param::Type* p = static_cast<comp_Param::Type*>(getParameterByEnum(ParameterTypes::comp)); if (!p) { p = new comp_Param::Type(ParameterTypes::comp); mParameters.push_back(p); } return p->value(); } const comp_Param::DType& ParserCategory::param(const comp_Param& paramType) const { checkParsed(); comp_Param::Type* p = static_cast<comp_Param::Type*>(getParameterByEnum(ParameterTypes::comp)); if (!p) { InfoLog(<< "Missing parameter " "comp" ); DebugLog(<< *this); throw Exception("Missing parameter " "comp", "ParserCategory.cxx.ixx.temp", 68); } return p->value(); };
dAlg_Param::DType& ParserCategory::param(const dAlg_Param& paramType) { checkParsed(); dAlg_Param::Type* p = static_cast<dAlg_Param::Type*>(getParameterByEnum(ParameterTypes::dAlg)); if (!p) { p = new dAlg_Param::Type(ParameterTypes::dAlg); mParameters.push_back(p); } return p->value(); } const dAlg_Param::DType& ParserCategory::param(const dAlg_Param& paramType) const { checkParsed(); dAlg_Param::Type* p = static_cast<dAlg_Param::Type*>(getParameterByEnum(ParameterTypes::dAlg)); if (!p) { InfoLog(<< "Missing parameter " "d-alg" ); DebugLog(<< *this); throw Exception("Missing parameter " "d-alg", "ParserCategory.cxx.ixx.temp", 69); } return p->value(); };
dQop_Param::DType& ParserCategory::param(const dQop_Param& paramType) { checkParsed(); dQop_Param::Type* p = static_cast<dQop_Param::Type*>(getParameterByEnum(ParameterTypes::dQop)); if (!p) { p = new dQop_Param::Type(ParameterTypes::dQop); mParameters.push_back(p); } return p->value(); } const dQop_Param::DType& ParserCategory::param(const dQop_Param& paramType) const { checkParsed(); dQop_Param::Type* p = static_cast<dQop_Param::Type*>(getParameterByEnum(ParameterTypes::dQop)); if (!p) { InfoLog(<< "Missing parameter " "d-qop" ); DebugLog(<< *this); throw Exception("Missing parameter " "d-qop", "ParserCategory.cxx.ixx.temp", 70); } return p->value(); };
dVer_Param::DType& ParserCategory::param(const dVer_Param& paramType) { checkParsed(); dVer_Param::Type* p = static_cast<dVer_Param::Type*>(getParameterByEnum(ParameterTypes::dVer)); if (!p) { p = new dVer_Param::Type(ParameterTypes::dVer); mParameters.push_back(p); } return p->value(); } const dVer_Param::DType& ParserCategory::param(const dVer_Param& paramType) const { checkParsed(); dVer_Param::Type* p = static_cast<dVer_Param::Type*>(getParameterByEnum(ParameterTypes::dVer)); if (!p) { InfoLog(<< "Missing parameter " "d-ver" ); DebugLog(<< *this); throw Exception("Missing parameter " "d-ver", "ParserCategory.cxx.ixx.temp", 71); } return p->value(); };
directory_Param::DType& ParserCategory::param(const directory_Param& paramType) { checkParsed(); directory_Param::Type* p = static_cast<directory_Param::Type*>(getParameterByEnum(ParameterTypes::directory)); if (!p) { p = new directory_Param::Type(ParameterTypes::directory); mParameters.push_back(p); } return p->value(); } const directory_Param::DType& ParserCategory::param(const directory_Param& paramType) const { checkParsed(); directory_Param::Type* p = static_cast<directory_Param::Type*>(getParameterByEnum(ParameterTypes::directory)); if (!p) { InfoLog(<< "Missing parameter " "directory" ); DebugLog(<< *this); throw Exception("Missing parameter " "directory", "ParserCategory.cxx.ixx.temp", 72); } return p->value(); };
domain_Param::DType& ParserCategory::param(const domain_Param& paramType) { checkParsed(); domain_Param::Type* p = static_cast<domain_Param::Type*>(getParameterByEnum(ParameterTypes::domain)); if (!p) { p = new domain_Param::Type(ParameterTypes::domain); mParameters.push_back(p); } return p->value(); } const domain_Param::DType& ParserCategory::param(const domain_Param& paramType) const { checkParsed(); domain_Param::Type* p = static_cast<domain_Param::Type*>(getParameterByEnum(ParameterTypes::domain)); if (!p) { InfoLog(<< "Missing parameter " "domain" ); DebugLog(<< *this); throw Exception("Missing parameter " "domain", "ParserCategory.cxx.ixx.temp", 73); } return p->value(); };
duration_Param::DType& ParserCategory::param(const duration_Param& paramType) { checkParsed(); duration_Param::Type* p = static_cast<duration_Param::Type*>(getParameterByEnum(ParameterTypes::duration)); if (!p) { p = new duration_Param::Type(ParameterTypes::duration); mParameters.push_back(p); } return p->value(); } const duration_Param::DType& ParserCategory::param(const duration_Param& paramType) const { checkParsed(); duration_Param::Type* p = static_cast<duration_Param::Type*>(getParameterByEnum(ParameterTypes::duration)); if (!p) { InfoLog(<< "Missing parameter " "duration" ); DebugLog(<< *this); throw Exception("Missing parameter " "duration", "ParserCategory.cxx.ixx.temp", 74); } return p->value(); };
expiration_Param::DType& ParserCategory::param(const expiration_Param& paramType) { checkParsed(); expiration_Param::Type* p = static_cast<expiration_Param::Type*>(getParameterByEnum(ParameterTypes::expiration)); if (!p) { p = new expiration_Param::Type(ParameterTypes::expiration); mParameters.push_back(p); } return p->value(); } const expiration_Param::DType& ParserCategory::param(const expiration_Param& paramType) const { checkParsed(); expiration_Param::Type* p = static_cast<expiration_Param::Type*>(getParameterByEnum(ParameterTypes::expiration)); if (!p) { InfoLog(<< "Missing parameter " "expiration" ); DebugLog(<< *this); throw Exception("Missing parameter " "expiration", "ParserCategory.cxx.ixx.temp", 75); } return p->value(); };
expires_Param::DType& ParserCategory::param(const expires_Param& paramType) { checkParsed(); expires_Param::Type* p = static_cast<expires_Param::Type*>(getParameterByEnum(ParameterTypes::expires)); if (!p) { p = new expires_Param::Type(ParameterTypes::expires); mParameters.push_back(p); } return p->value(); } const expires_Param::DType& ParserCategory::param(const expires_Param& paramType) const { checkParsed(); expires_Param::Type* p = static_cast<expires_Param::Type*>(getParameterByEnum(ParameterTypes::expires)); if (!p) { InfoLog(<< "Missing parameter " "expires" ); DebugLog(<< *this); throw Exception("Missing parameter " "expires", "ParserCategory.cxx.ixx.temp", 76); } return p->value(); };
filename_Param::DType& ParserCategory::param(const filename_Param& paramType) { checkParsed(); filename_Param::Type* p = static_cast<filename_Param::Type*>(getParameterByEnum(ParameterTypes::filename)); if (!p) { p = new filename_Param::Type(ParameterTypes::filename); mParameters.push_back(p); } return p->value(); } const filename_Param::DType& ParserCategory::param(const filename_Param& paramType) const { checkParsed(); filename_Param::Type* p = static_cast<filename_Param::Type*>(getParameterByEnum(ParameterTypes::filename)); if (!p) { InfoLog(<< "Missing parameter " "filename" ); DebugLog(<< *this); throw Exception("Missing parameter " "filename", "ParserCategory.cxx.ixx.temp", 77); } return p->value(); };
fromTag_Param::DType& ParserCategory::param(const fromTag_Param& paramType) { checkParsed(); fromTag_Param::Type* p = static_cast<fromTag_Param::Type*>(getParameterByEnum(ParameterTypes::fromTag)); if (!p) { p = new fromTag_Param::Type(ParameterTypes::fromTag); mParameters.push_back(p); } return p->value(); } const fromTag_Param::DType& ParserCategory::param(const fromTag_Param& paramType) const { checkParsed(); fromTag_Param::Type* p = static_cast<fromTag_Param::Type*>(getParameterByEnum(ParameterTypes::fromTag)); if (!p) { InfoLog(<< "Missing parameter " "from-tag" ); DebugLog(<< *this); throw Exception("Missing parameter " "from-tag", "ParserCategory.cxx.ixx.temp", 78); } return p->value(); };
handling_Param::DType& ParserCategory::param(const handling_Param& paramType) { checkParsed(); handling_Param::Type* p = static_cast<handling_Param::Type*>(getParameterByEnum(ParameterTypes::handling)); if (!p) { p = new handling_Param::Type(ParameterTypes::handling); mParameters.push_back(p); } return p->value(); } const handling_Param::DType& ParserCategory::param(const handling_Param& paramType) const { checkParsed(); handling_Param::Type* p = static_cast<handling_Param::Type*>(getParameterByEnum(ParameterTypes::handling)); if (!p) { InfoLog(<< "Missing parameter " "handling" ); DebugLog(<< *this); throw Exception("Missing parameter " "handling", "ParserCategory.cxx.ixx.temp", 79); } return p->value(); };
id_Param::DType& ParserCategory::param(const id_Param& paramType) { checkParsed(); id_Param::Type* p = static_cast<id_Param::Type*>(getParameterByEnum(ParameterTypes::id)); if (!p) { p = new id_Param::Type(ParameterTypes::id); mParameters.push_back(p); } return p->value(); } const id_Param::DType& ParserCategory::param(const id_Param& paramType) const { checkParsed(); id_Param::Type* p = static_cast<id_Param::Type*>(getParameterByEnum(ParameterTypes::id)); if (!p) { InfoLog(<< "Missing parameter " "id" ); DebugLog(<< *this); throw Exception("Missing parameter " "id", "ParserCategory.cxx.ixx.temp", 80); } return p->value(); };
lr_Param::DType& ParserCategory::param(const lr_Param& paramType) { checkParsed(); lr_Param::Type* p = static_cast<lr_Param::Type*>(getParameterByEnum(ParameterTypes::lr)); if (!p) { p = new lr_Param::Type(ParameterTypes::lr); mParameters.push_back(p); } return p->value(); } const lr_Param::DType& ParserCategory::param(const lr_Param& paramType) const { checkParsed(); lr_Param::Type* p = static_cast<lr_Param::Type*>(getParameterByEnum(ParameterTypes::lr)); if (!p) { InfoLog(<< "Missing parameter " "lr" ); DebugLog(<< *this); throw Exception("Missing parameter " "lr", "ParserCategory.cxx.ixx.temp", 81); } return p->value(); };
maddr_Param::DType& ParserCategory::param(const maddr_Param& paramType) { checkParsed(); maddr_Param::Type* p = static_cast<maddr_Param::Type*>(getParameterByEnum(ParameterTypes::maddr)); if (!p) { p = new maddr_Param::Type(ParameterTypes::maddr); mParameters.push_back(p); } return p->value(); } const maddr_Param::DType& ParserCategory::param(const maddr_Param& paramType) const { checkParsed(); maddr_Param::Type* p = static_cast<maddr_Param::Type*>(getParameterByEnum(ParameterTypes::maddr)); if (!p) { InfoLog(<< "Missing parameter " "maddr" ); DebugLog(<< *this); throw Exception("Missing parameter " "maddr", "ParserCategory.cxx.ixx.temp", 82); } return p->value(); };
method_Param::DType& ParserCategory::param(const method_Param& paramType) { checkParsed(); method_Param::Type* p = static_cast<method_Param::Type*>(getParameterByEnum(ParameterTypes::method)); if (!p) { p = new method_Param::Type(ParameterTypes::method); mParameters.push_back(p); } return p->value(); } const method_Param::DType& ParserCategory::param(const method_Param& paramType) const { checkParsed(); method_Param::Type* p = static_cast<method_Param::Type*>(getParameterByEnum(ParameterTypes::method)); if (!p) { InfoLog(<< "Missing parameter " "method" ); DebugLog(<< *this); throw Exception("Missing parameter " "method", "ParserCategory.cxx.ixx.temp", 83); } return p->value(); };
micalg_Param::DType& ParserCategory::param(const micalg_Param& paramType) { checkParsed(); micalg_Param::Type* p = static_cast<micalg_Param::Type*>(getParameterByEnum(ParameterTypes::micalg)); if (!p) { p = new micalg_Param::Type(ParameterTypes::micalg); mParameters.push_back(p); } return p->value(); } const micalg_Param::DType& ParserCategory::param(const micalg_Param& paramType) const { checkParsed(); micalg_Param::Type* p = static_cast<micalg_Param::Type*>(getParameterByEnum(ParameterTypes::micalg)); if (!p) { InfoLog(<< "Missing parameter " "micalg" ); DebugLog(<< *this); throw Exception("Missing parameter " "micalg", "ParserCategory.cxx.ixx.temp", 84); } return p->value(); };
mode_Param::DType& ParserCategory::param(const mode_Param& paramType) { checkParsed(); mode_Param::Type* p = static_cast<mode_Param::Type*>(getParameterByEnum(ParameterTypes::mode)); if (!p) { p = new mode_Param::Type(ParameterTypes::mode); mParameters.push_back(p); } return p->value(); } const mode_Param::DType& ParserCategory::param(const mode_Param& paramType) const { checkParsed(); mode_Param::Type* p = static_cast<mode_Param::Type*>(getParameterByEnum(ParameterTypes::mode)); if (!p) { InfoLog(<< "Missing parameter " "mode" ); DebugLog(<< *this); throw Exception("Missing parameter " "mode", "ParserCategory.cxx.ixx.temp", 85); } return p->value(); };
name_Param::DType& ParserCategory::param(const name_Param& paramType) { checkParsed(); name_Param::Type* p = static_cast<name_Param::Type*>(getParameterByEnum(ParameterTypes::name)); if (!p) { p = new name_Param::Type(ParameterTypes::name); mParameters.push_back(p); } return p->value(); } const name_Param::DType& ParserCategory::param(const name_Param& paramType) const { checkParsed(); name_Param::Type* p = static_cast<name_Param::Type*>(getParameterByEnum(ParameterTypes::name)); if (!p) { InfoLog(<< "Missing parameter " "name" ); DebugLog(<< *this); throw Exception("Missing parameter " "name", "ParserCategory.cxx.ixx.temp", 86); } return p->value(); };
nc_Param::DType& ParserCategory::param(const nc_Param& paramType) { checkParsed(); nc_Param::Type* p = static_cast<nc_Param::Type*>(getParameterByEnum(ParameterTypes::nc)); if (!p) { p = new nc_Param::Type(ParameterTypes::nc); mParameters.push_back(p); } return p->value(); } const nc_Param::DType& ParserCategory::param(const nc_Param& paramType) const { checkParsed(); nc_Param::Type* p = static_cast<nc_Param::Type*>(getParameterByEnum(ParameterTypes::nc)); if (!p) { InfoLog(<< "Missing parameter " "nc" ); DebugLog(<< *this); throw Exception("Missing parameter " "nc", "ParserCategory.cxx.ixx.temp", 87); } return p->value(); };
nonce_Param::DType& ParserCategory::param(const nonce_Param& paramType) { checkParsed(); nonce_Param::Type* p = static_cast<nonce_Param::Type*>(getParameterByEnum(ParameterTypes::nonce)); if (!p) { p = new nonce_Param::Type(ParameterTypes::nonce); mParameters.push_back(p); } return p->value(); } const nonce_Param::DType& ParserCategory::param(const nonce_Param& paramType) const { checkParsed(); nonce_Param::Type* p = static_cast<nonce_Param::Type*>(getParameterByEnum(ParameterTypes::nonce)); if (!p) { InfoLog(<< "Missing parameter " "nonce" ); DebugLog(<< *this); throw Exception("Missing parameter " "nonce", "ParserCategory.cxx.ixx.temp", 88); } return p->value(); };
opaque_Param::DType& ParserCategory::param(const opaque_Param& paramType) { checkParsed(); opaque_Param::Type* p = static_cast<opaque_Param::Type*>(getParameterByEnum(ParameterTypes::opaque)); if (!p) { p = new opaque_Param::Type(ParameterTypes::opaque); mParameters.push_back(p); } return p->value(); } const opaque_Param::DType& ParserCategory::param(const opaque_Param& paramType) const { checkParsed(); opaque_Param::Type* p = static_cast<opaque_Param::Type*>(getParameterByEnum(ParameterTypes::opaque)); if (!p) { InfoLog(<< "Missing parameter " "opaque" ); DebugLog(<< *this); throw Exception("Missing parameter " "opaque", "ParserCategory.cxx.ixx.temp", 89); } return p->value(); };
permission_Param::DType& ParserCategory::param(const permission_Param& paramType) { checkParsed(); permission_Param::Type* p = static_cast<permission_Param::Type*>(getParameterByEnum(ParameterTypes::permission)); if (!p) { p = new permission_Param::Type(ParameterTypes::permission); mParameters.push_back(p); } return p->value(); } const permission_Param::DType& ParserCategory::param(const permission_Param& paramType) const { checkParsed(); permission_Param::Type* p = static_cast<permission_Param::Type*>(getParameterByEnum(ParameterTypes::permission)); if (!p) { InfoLog(<< "Missing parameter " "permission" ); DebugLog(<< *this); throw Exception("Missing parameter " "permission", "ParserCategory.cxx.ixx.temp", 90); } return p->value(); };
protocol_Param::DType& ParserCategory::param(const protocol_Param& paramType) { checkParsed(); protocol_Param::Type* p = static_cast<protocol_Param::Type*>(getParameterByEnum(ParameterTypes::protocol)); if (!p) { p = new protocol_Param::Type(ParameterTypes::protocol); mParameters.push_back(p); } return p->value(); } const protocol_Param::DType& ParserCategory::param(const protocol_Param& paramType) const { checkParsed(); protocol_Param::Type* p = static_cast<protocol_Param::Type*>(getParameterByEnum(ParameterTypes::protocol)); if (!p) { InfoLog(<< "Missing parameter " "protocol" ); DebugLog(<< *this); throw Exception("Missing parameter " "protocol", "ParserCategory.cxx.ixx.temp", 91); } return p->value(); };
purpose_Param::DType& ParserCategory::param(const purpose_Param& paramType) { checkParsed(); purpose_Param::Type* p = static_cast<purpose_Param::Type*>(getParameterByEnum(ParameterTypes::purpose)); if (!p) { p = new purpose_Param::Type(ParameterTypes::purpose); mParameters.push_back(p); } return p->value(); } const purpose_Param::DType& ParserCategory::param(const purpose_Param& paramType) const { checkParsed(); purpose_Param::Type* p = static_cast<purpose_Param::Type*>(getParameterByEnum(ParameterTypes::purpose)); if (!p) { InfoLog(<< "Missing parameter " "purpose" ); DebugLog(<< *this); throw Exception("Missing parameter " "purpose", "ParserCategory.cxx.ixx.temp", 92); } return p->value(); };
q_Param::DType& ParserCategory::param(const q_Param& paramType) { checkParsed(); q_Param::Type* p = static_cast<q_Param::Type*>(getParameterByEnum(ParameterTypes::q)); if (!p) { p = new q_Param::Type(ParameterTypes::q); mParameters.push_back(p); } return p->value(); } const q_Param::DType& ParserCategory::param(const q_Param& paramType) const { checkParsed(); q_Param::Type* p = static_cast<q_Param::Type*>(getParameterByEnum(ParameterTypes::q)); if (!p) { InfoLog(<< "Missing parameter " "q" ); DebugLog(<< *this); throw Exception("Missing parameter " "q", "ParserCategory.cxx.ixx.temp", 93); } return p->value(); };
realm_Param::DType& ParserCategory::param(const realm_Param& paramType) { checkParsed(); realm_Param::Type* p = static_cast<realm_Param::Type*>(getParameterByEnum(ParameterTypes::realm)); if (!p) { p = new realm_Param::Type(ParameterTypes::realm); mParameters.push_back(p); } return p->value(); } const realm_Param::DType& ParserCategory::param(const realm_Param& paramType) const { checkParsed(); realm_Param::Type* p = static_cast<realm_Param::Type*>(getParameterByEnum(ParameterTypes::realm)); if (!p) { InfoLog(<< "Missing parameter " "realm" ); DebugLog(<< *this); throw Exception("Missing parameter " "realm", "ParserCategory.cxx.ixx.temp", 94); } return p->value(); };
reason_Param::DType& ParserCategory::param(const reason_Param& paramType) { checkParsed(); reason_Param::Type* p = static_cast<reason_Param::Type*>(getParameterByEnum(ParameterTypes::reason)); if (!p) { p = new reason_Param::Type(ParameterTypes::reason); mParameters.push_back(p); } return p->value(); } const reason_Param::DType& ParserCategory::param(const reason_Param& paramType) const { checkParsed(); reason_Param::Type* p = static_cast<reason_Param::Type*>(getParameterByEnum(ParameterTypes::reason)); if (!p) { InfoLog(<< "Missing parameter " "reason" ); DebugLog(<< *this); throw Exception("Missing parameter " "reason", "ParserCategory.cxx.ixx.temp", 95); } return p->value(); };
received_Param::DType& ParserCategory::param(const received_Param& paramType) { checkParsed(); received_Param::Type* p = static_cast<received_Param::Type*>(getParameterByEnum(ParameterTypes::received)); if (!p) { p = new received_Param::Type(ParameterTypes::received); mParameters.push_back(p); } return p->value(); } const received_Param::DType& ParserCategory::param(const received_Param& paramType) const { checkParsed(); received_Param::Type* p = static_cast<received_Param::Type*>(getParameterByEnum(ParameterTypes::received)); if (!p) { InfoLog(<< "Missing parameter " "received" ); DebugLog(<< *this); throw Exception("Missing parameter " "received", "ParserCategory.cxx.ixx.temp", 96); } return p->value(); };
response_Param::DType& ParserCategory::param(const response_Param& paramType) { checkParsed(); response_Param::Type* p = static_cast<response_Param::Type*>(getParameterByEnum(ParameterTypes::response)); if (!p) { p = new response_Param::Type(ParameterTypes::response); mParameters.push_back(p); } return p->value(); } const response_Param::DType& ParserCategory::param(const response_Param& paramType) const { checkParsed(); response_Param::Type* p = static_cast<response_Param::Type*>(getParameterByEnum(ParameterTypes::response)); if (!p) { InfoLog(<< "Missing parameter " "response" ); DebugLog(<< *this); throw Exception("Missing parameter " "response", "ParserCategory.cxx.ixx.temp", 97); } return p->value(); };
retryAfter_Param::DType& ParserCategory::param(const retryAfter_Param& paramType) { checkParsed(); retryAfter_Param::Type* p = static_cast<retryAfter_Param::Type*>(getParameterByEnum(ParameterTypes::retryAfter)); if (!p) { p = new retryAfter_Param::Type(ParameterTypes::retryAfter); mParameters.push_back(p); } return p->value(); } const retryAfter_Param::DType& ParserCategory::param(const retryAfter_Param& paramType) const { checkParsed(); retryAfter_Param::Type* p = static_cast<retryAfter_Param::Type*>(getParameterByEnum(ParameterTypes::retryAfter)); if (!p) { InfoLog(<< "Missing parameter " "retry-after" ); DebugLog(<< *this); throw Exception("Missing parameter " "retry-after", "ParserCategory.cxx.ixx.temp", 98); } return p->value(); };
rinstance_Param::DType& ParserCategory::param(const rinstance_Param& paramType) { checkParsed(); rinstance_Param::Type* p = static_cast<rinstance_Param::Type*>(getParameterByEnum(ParameterTypes::rinstance)); if (!p) { p = new rinstance_Param::Type(ParameterTypes::rinstance); mParameters.push_back(p); } return p->value(); } const rinstance_Param::DType& ParserCategory::param(const rinstance_Param& paramType) const { checkParsed(); rinstance_Param::Type* p = static_cast<rinstance_Param::Type*>(getParameterByEnum(ParameterTypes::rinstance)); if (!p) { InfoLog(<< "Missing parameter " "rinstance" ); DebugLog(<< *this); throw Exception("Missing parameter " "rinstance", "ParserCategory.cxx.ixx.temp", 99); } return p->value(); };
rport_Param::DType& ParserCategory::param(const rport_Param& paramType) { checkParsed(); rport_Param::Type* p = static_cast<rport_Param::Type*>(getParameterByEnum(ParameterTypes::rport)); if (!p) { p = new rport_Param::Type(ParameterTypes::rport); mParameters.push_back(p); } return p->value(); } const rport_Param::DType& ParserCategory::param(const rport_Param& paramType) const { checkParsed(); rport_Param::Type* p = static_cast<rport_Param::Type*>(getParameterByEnum(ParameterTypes::rport)); if (!p) { InfoLog(<< "Missing parameter " "rport" ); DebugLog(<< *this); throw Exception("Missing parameter " "rport", "ParserCategory.cxx.ixx.temp", 100); } return p->value(); };
server_Param::DType& ParserCategory::param(const server_Param& paramType) { checkParsed(); server_Param::Type* p = static_cast<server_Param::Type*>(getParameterByEnum(ParameterTypes::server)); if (!p) { p = new server_Param::Type(ParameterTypes::server); mParameters.push_back(p); } return p->value(); } const server_Param::DType& ParserCategory::param(const server_Param& paramType) const { checkParsed(); server_Param::Type* p = static_cast<server_Param::Type*>(getParameterByEnum(ParameterTypes::server)); if (!p) { InfoLog(<< "Missing parameter " "server" ); DebugLog(<< *this); throw Exception("Missing parameter " "server", "ParserCategory.cxx.ixx.temp", 101); } return p->value(); };
site_Param::DType& ParserCategory::param(const site_Param& paramType) { checkParsed(); site_Param::Type* p = static_cast<site_Param::Type*>(getParameterByEnum(ParameterTypes::site)); if (!p) { p = new site_Param::Type(ParameterTypes::site); mParameters.push_back(p); } return p->value(); } const site_Param::DType& ParserCategory::param(const site_Param& paramType) const { checkParsed(); site_Param::Type* p = static_cast<site_Param::Type*>(getParameterByEnum(ParameterTypes::site)); if (!p) { InfoLog(<< "Missing parameter " "site" ); DebugLog(<< *this); throw Exception("Missing parameter " "site", "ParserCategory.cxx.ixx.temp", 102); } return p->value(); };
size_Param::DType& ParserCategory::param(const size_Param& paramType) { checkParsed(); size_Param::Type* p = static_cast<size_Param::Type*>(getParameterByEnum(ParameterTypes::size)); if (!p) { p = new size_Param::Type(ParameterTypes::size); mParameters.push_back(p); } return p->value(); } const size_Param::DType& ParserCategory::param(const size_Param& paramType) const { checkParsed(); size_Param::Type* p = static_cast<size_Param::Type*>(getParameterByEnum(ParameterTypes::size)); if (!p) { InfoLog(<< "Missing parameter " "size" ); DebugLog(<< *this); throw Exception("Missing parameter " "size", "ParserCategory.cxx.ixx.temp", 103); } return p->value(); };
smimeType_Param::DType& ParserCategory::param(const smimeType_Param& paramType) { checkParsed(); smimeType_Param::Type* p = static_cast<smimeType_Param::Type*>(getParameterByEnum(ParameterTypes::smimeType)); if (!p) { p = new smimeType_Param::Type(ParameterTypes::smimeType); mParameters.push_back(p); } return p->value(); } const smimeType_Param::DType& ParserCategory::param(const smimeType_Param& paramType) const { checkParsed(); smimeType_Param::Type* p = static_cast<smimeType_Param::Type*>(getParameterByEnum(ParameterTypes::smimeType)); if (!p) { InfoLog(<< "Missing parameter " "smime-type" ); DebugLog(<< *this); throw Exception("Missing parameter " "smime-type", "ParserCategory.cxx.ixx.temp", 104); } return p->value(); };
stale_Param::DType& ParserCategory::param(const stale_Param& paramType) { checkParsed(); stale_Param::Type* p = static_cast<stale_Param::Type*>(getParameterByEnum(ParameterTypes::stale)); if (!p) { p = new stale_Param::Type(ParameterTypes::stale); mParameters.push_back(p); } return p->value(); } const stale_Param::DType& ParserCategory::param(const stale_Param& paramType) const { checkParsed(); stale_Param::Type* p = static_cast<stale_Param::Type*>(getParameterByEnum(ParameterTypes::stale)); if (!p) { InfoLog(<< "Missing parameter " "stale" ); DebugLog(<< *this); throw Exception("Missing parameter " "stale", "ParserCategory.cxx.ixx.temp", 105); } return p->value(); };
tag_Param::DType& ParserCategory::param(const tag_Param& paramType) { checkParsed(); tag_Param::Type* p = static_cast<tag_Param::Type*>(getParameterByEnum(ParameterTypes::tag)); if (!p) { p = new tag_Param::Type(ParameterTypes::tag); mParameters.push_back(p); } return p->value(); } const tag_Param::DType& ParserCategory::param(const tag_Param& paramType) const { checkParsed(); tag_Param::Type* p = static_cast<tag_Param::Type*>(getParameterByEnum(ParameterTypes::tag)); if (!p) { InfoLog(<< "Missing parameter " "tag" ); DebugLog(<< *this); throw Exception("Missing parameter " "tag", "ParserCategory.cxx.ixx.temp", 106); } return p->value(); };
toTag_Param::DType& ParserCategory::param(const toTag_Param& paramType) { checkParsed(); toTag_Param::Type* p = static_cast<toTag_Param::Type*>(getParameterByEnum(ParameterTypes::toTag)); if (!p) { p = new toTag_Param::Type(ParameterTypes::toTag); mParameters.push_back(p); } return p->value(); } const toTag_Param::DType& ParserCategory::param(const toTag_Param& paramType) const { checkParsed(); toTag_Param::Type* p = static_cast<toTag_Param::Type*>(getParameterByEnum(ParameterTypes::toTag)); if (!p) { InfoLog(<< "Missing parameter " "to-tag" ); DebugLog(<< *this); throw Exception("Missing parameter " "to-tag", "ParserCategory.cxx.ixx.temp", 107); } return p->value(); };
transport_Param::DType& ParserCategory::param(const transport_Param& paramType) { checkParsed(); transport_Param::Type* p = static_cast<transport_Param::Type*>(getParameterByEnum(ParameterTypes::transport)); if (!p) { p = new transport_Param::Type(ParameterTypes::transport); mParameters.push_back(p); } return p->value(); } const transport_Param::DType& ParserCategory::param(const transport_Param& paramType) const { checkParsed(); transport_Param::Type* p = static_cast<transport_Param::Type*>(getParameterByEnum(ParameterTypes::transport)); if (!p) { InfoLog(<< "Missing parameter " "transport" ); DebugLog(<< *this); throw Exception("Missing parameter " "transport", "ParserCategory.cxx.ixx.temp", 108); } return p->value(); };
ttl_Param::DType& ParserCategory::param(const ttl_Param& paramType) { checkParsed(); ttl_Param::Type* p = static_cast<ttl_Param::Type*>(getParameterByEnum(ParameterTypes::ttl)); if (!p) { p = new ttl_Param::Type(ParameterTypes::ttl); mParameters.push_back(p); } return p->value(); } const ttl_Param::DType& ParserCategory::param(const ttl_Param& paramType) const { checkParsed(); ttl_Param::Type* p = static_cast<ttl_Param::Type*>(getParameterByEnum(ParameterTypes::ttl)); if (!p) { InfoLog(<< "Missing parameter " "ttl" ); DebugLog(<< *this); throw Exception("Missing parameter " "ttl", "ParserCategory.cxx.ixx.temp", 109); } return p->value(); };
uri_Param::DType& ParserCategory::param(const uri_Param& paramType) { checkParsed(); uri_Param::Type* p = static_cast<uri_Param::Type*>(getParameterByEnum(ParameterTypes::uri)); if (!p) { p = new uri_Param::Type(ParameterTypes::uri); mParameters.push_back(p); } return p->value(); } const uri_Param::DType& ParserCategory::param(const uri_Param& paramType) const { checkParsed(); uri_Param::Type* p = static_cast<uri_Param::Type*>(getParameterByEnum(ParameterTypes::uri)); if (!p) { InfoLog(<< "Missing parameter " "uri" ); DebugLog(<< *this); throw Exception("Missing parameter " "uri", "ParserCategory.cxx.ixx.temp", 110); } return p->value(); };
user_Param::DType& ParserCategory::param(const user_Param& paramType) { checkParsed(); user_Param::Type* p = static_cast<user_Param::Type*>(getParameterByEnum(ParameterTypes::user)); if (!p) { p = new user_Param::Type(ParameterTypes::user); mParameters.push_back(p); } return p->value(); } const user_Param::DType& ParserCategory::param(const user_Param& paramType) const { checkParsed(); user_Param::Type* p = static_cast<user_Param::Type*>(getParameterByEnum(ParameterTypes::user)); if (!p) { InfoLog(<< "Missing parameter " "user" ); DebugLog(<< *this); throw Exception("Missing parameter " "user", "ParserCategory.cxx.ixx.temp", 111); } return p->value(); };
extension_Param::DType& ParserCategory::param(const extension_Param& paramType) { checkParsed(); extension_Param::Type* p = static_cast<extension_Param::Type*>(getParameterByEnum(ParameterTypes::extension)); if (!p) { p = new extension_Param::Type(ParameterTypes::extension); mParameters.push_back(p); } return p->value(); } const extension_Param::DType& ParserCategory::param(const extension_Param& paramType) const { checkParsed(); extension_Param::Type* p = static_cast<extension_Param::Type*>(getParameterByEnum(ParameterTypes::extension)); if (!p) { InfoLog(<< "Missing parameter " "ext" ); DebugLog(<< *this); throw Exception("Missing parameter " "ext", "ParserCategory.cxx.ixx.temp", 112); } return p->value(); };
username_Param::DType& ParserCategory::param(const username_Param& paramType) { checkParsed(); username_Param::Type* p = static_cast<username_Param::Type*>(getParameterByEnum(ParameterTypes::username)); if (!p) { p = new username_Param::Type(ParameterTypes::username); mParameters.push_back(p); } return p->value(); } const username_Param::DType& ParserCategory::param(const username_Param& paramType) const { checkParsed(); username_Param::Type* p = static_cast<username_Param::Type*>(getParameterByEnum(ParameterTypes::username)); if (!p) { InfoLog(<< "Missing parameter " "username" ); DebugLog(<< *this); throw Exception("Missing parameter " "username", "ParserCategory.cxx.ixx.temp", 113); } return p->value(); };
earlyOnly_Param::DType& ParserCategory::param(const earlyOnly_Param& paramType) { checkParsed(); earlyOnly_Param::Type* p = static_cast<earlyOnly_Param::Type*>(getParameterByEnum(ParameterTypes::earlyOnly)); if (!p) { p = new earlyOnly_Param::Type(ParameterTypes::earlyOnly); mParameters.push_back(p); } return p->value(); } const earlyOnly_Param::DType& ParserCategory::param(const earlyOnly_Param& paramType) const { checkParsed(); earlyOnly_Param::Type* p = static_cast<earlyOnly_Param::Type*>(getParameterByEnum(ParameterTypes::earlyOnly)); if (!p) { InfoLog(<< "Missing parameter " "early-only" ); DebugLog(<< *this); throw Exception("Missing parameter " "early-only", "ParserCategory.cxx.ixx.temp", 114); } return p->value(); };
refresher_Param::DType& ParserCategory::param(const refresher_Param& paramType) { checkParsed(); refresher_Param::Type* p = static_cast<refresher_Param::Type*>(getParameterByEnum(ParameterTypes::refresher)); if (!p) { p = new refresher_Param::Type(ParameterTypes::refresher); mParameters.push_back(p); } return p->value(); } const refresher_Param::DType& ParserCategory::param(const refresher_Param& paramType) const { checkParsed(); refresher_Param::Type* p = static_cast<refresher_Param::Type*>(getParameterByEnum(ParameterTypes::refresher)); if (!p) { InfoLog(<< "Missing parameter " "refresher" ); DebugLog(<< *this); throw Exception("Missing parameter " "refresher", "ParserCategory.cxx.ixx.temp", 115); } return p->value(); };
profileType_Param::DType& ParserCategory::param(const profileType_Param& paramType) { checkParsed(); profileType_Param::Type* p = static_cast<profileType_Param::Type*>(getParameterByEnum(ParameterTypes::profileType)); if (!p) { p = new profileType_Param::Type(ParameterTypes::profileType); mParameters.push_back(p); } return p->value(); } const profileType_Param::DType& ParserCategory::param(const profileType_Param& paramType) const { checkParsed(); profileType_Param::Type* p = static_cast<profileType_Param::Type*>(getParameterByEnum(ParameterTypes::profileType)); if (!p) { InfoLog(<< "Missing parameter " "profile-type" ); DebugLog(<< *this); throw Exception("Missing parameter " "profile-type", "ParserCategory.cxx.ixx.temp", 116); } return p->value(); };
vendor_Param::DType& ParserCategory::param(const vendor_Param& paramType) { checkParsed(); vendor_Param::Type* p = static_cast<vendor_Param::Type*>(getParameterByEnum(ParameterTypes::vendor)); if (!p) { p = new vendor_Param::Type(ParameterTypes::vendor); mParameters.push_back(p); } return p->value(); } const vendor_Param::DType& ParserCategory::param(const vendor_Param& paramType) const { checkParsed(); vendor_Param::Type* p = static_cast<vendor_Param::Type*>(getParameterByEnum(ParameterTypes::vendor)); if (!p) { InfoLog(<< "Missing parameter " "vendor" ); DebugLog(<< *this); throw Exception("Missing parameter " "vendor", "ParserCategory.cxx.ixx.temp", 117); } return p->value(); };
model_Param::DType& ParserCategory::param(const model_Param& paramType) { checkParsed(); model_Param::Type* p = static_cast<model_Param::Type*>(getParameterByEnum(ParameterTypes::model)); if (!p) { p = new model_Param::Type(ParameterTypes::model); mParameters.push_back(p); } return p->value(); } const model_Param::DType& ParserCategory::param(const model_Param& paramType) const { checkParsed(); model_Param::Type* p = static_cast<model_Param::Type*>(getParameterByEnum(ParameterTypes::model)); if (!p) { InfoLog(<< "Missing parameter " "model" ); DebugLog(<< *this); throw Exception("Missing parameter " "model", "ParserCategory.cxx.ixx.temp", 118); } return p->value(); };
version_Param::DType& ParserCategory::param(const version_Param& paramType) { checkParsed(); version_Param::Type* p = static_cast<version_Param::Type*>(getParameterByEnum(ParameterTypes::version)); if (!p) { p = new version_Param::Type(ParameterTypes::version); mParameters.push_back(p); } return p->value(); } const version_Param::DType& ParserCategory::param(const version_Param& paramType) const { checkParsed(); version_Param::Type* p = static_cast<version_Param::Type*>(getParameterByEnum(ParameterTypes::version)); if (!p) { InfoLog(<< "Missing parameter " "version" ); DebugLog(<< *this); throw Exception("Missing parameter " "version", "ParserCategory.cxx.ixx.temp", 119); } return p->value(); };
effectiveBy_Param::DType& ParserCategory::param(const effectiveBy_Param& paramType) { checkParsed(); effectiveBy_Param::Type* p = static_cast<effectiveBy_Param::Type*>(getParameterByEnum(ParameterTypes::effectiveBy)); if (!p) { p = new effectiveBy_Param::Type(ParameterTypes::effectiveBy); mParameters.push_back(p); } return p->value(); } const effectiveBy_Param::DType& ParserCategory::param(const effectiveBy_Param& paramType) const { checkParsed(); effectiveBy_Param::Type* p = static_cast<effectiveBy_Param::Type*>(getParameterByEnum(ParameterTypes::effectiveBy)); if (!p) { InfoLog(<< "Missing parameter " "effective-by" ); DebugLog(<< *this); throw Exception("Missing parameter " "effective-by", "ParserCategory.cxx.ixx.temp", 120); } return p->value(); };
document_Param::DType& ParserCategory::param(const document_Param& paramType) { checkParsed(); document_Param::Type* p = static_cast<document_Param::Type*>(getParameterByEnum(ParameterTypes::document)); if (!p) { p = new document_Param::Type(ParameterTypes::document); mParameters.push_back(p); } return p->value(); } const document_Param::DType& ParserCategory::param(const document_Param& paramType) const { checkParsed(); document_Param::Type* p = static_cast<document_Param::Type*>(getParameterByEnum(ParameterTypes::document)); if (!p) { InfoLog(<< "Missing parameter " "document" ); DebugLog(<< *this); throw Exception("Missing parameter " "document", "ParserCategory.cxx.ixx.temp", 121); } return p->value(); };
appId_Param::DType& ParserCategory::param(const appId_Param& paramType) { checkParsed(); appId_Param::Type* p = static_cast<appId_Param::Type*>(getParameterByEnum(ParameterTypes::appId)); if (!p) { p = new appId_Param::Type(ParameterTypes::appId); mParameters.push_back(p); } return p->value(); } const appId_Param::DType& ParserCategory::param(const appId_Param& paramType) const { checkParsed(); appId_Param::Type* p = static_cast<appId_Param::Type*>(getParameterByEnum(ParameterTypes::appId)); if (!p) { InfoLog(<< "Missing parameter " "app-id" ); DebugLog(<< *this); throw Exception("Missing parameter " "app-id", "ParserCategory.cxx.ixx.temp", 122); } return p->value(); };
networkUser_Param::DType& ParserCategory::param(const networkUser_Param& paramType) { checkParsed(); networkUser_Param::Type* p = static_cast<networkUser_Param::Type*>(getParameterByEnum(ParameterTypes::networkUser)); if (!p) { p = new networkUser_Param::Type(ParameterTypes::networkUser); mParameters.push_back(p); } return p->value(); } const networkUser_Param::DType& ParserCategory::param(const networkUser_Param& paramType) const { checkParsed(); networkUser_Param::Type* p = static_cast<networkUser_Param::Type*>(getParameterByEnum(ParameterTypes::networkUser)); if (!p) { InfoLog(<< "Missing parameter " "network-user" ); DebugLog(<< *this); throw Exception("Missing parameter " "network-user", "ParserCategory.cxx.ixx.temp", 123); } return p->value(); };
url_Param::DType& ParserCategory::param(const url_Param& paramType) { checkParsed(); url_Param::Type* p = static_cast<url_Param::Type*>(getParameterByEnum(ParameterTypes::url)); if (!p) { p = new url_Param::Type(ParameterTypes::url); mParameters.push_back(p); } return p->value(); } const url_Param::DType& ParserCategory::param(const url_Param& paramType) const { checkParsed(); url_Param::Type* p = static_cast<url_Param::Type*>(getParameterByEnum(ParameterTypes::url)); if (!p) { InfoLog(<< "Missing parameter " "url" ); DebugLog(<< *this); throw Exception("Missing parameter " "url", "ParserCategory.cxx.ixx.temp", 124); } return p->value(); };
qop_Param::DType& ParserCategory::param(const qop_Param& paramType) { checkParsed(); qop_Param::Type* p = static_cast<qop_Param::Type*>(getParameterByEnum(ParameterTypes::qop)); if (!p) { p = new qop_Param::Type(ParameterTypes::qop); mParameters.push_back(p); } return p->value(); } const qop_Param::DType& ParserCategory::param(const qop_Param& paramType) const { checkParsed(); qop_Param::Type* p = static_cast<qop_Param::Type*>(getParameterByEnum(ParameterTypes::qop)); if (!p) { InfoLog(<< "Missing parameter " "qop" ); DebugLog(<< *this); throw Exception("Missing parameter " "qop", "ParserCategory.cxx.ixx.temp", 125); } return p->value(); };
sigcompId_Param::DType& ParserCategory::param(const sigcompId_Param& paramType) { checkParsed(); sigcompId_Param::Type* p = static_cast<sigcompId_Param::Type*>(getParameterByEnum(ParameterTypes::sigcompId)); if (!p) { p = new sigcompId_Param::Type(ParameterTypes::sigcompId); mParameters.push_back(p); } return p->value(); } const sigcompId_Param::DType& ParserCategory::param(const sigcompId_Param& paramType) const { checkParsed(); sigcompId_Param::Type* p = static_cast<sigcompId_Param::Type*>(getParameterByEnum(ParameterTypes::sigcompId)); if (!p) { InfoLog(<< "Missing parameter " "sigcomp-id" ); DebugLog(<< *this); throw Exception("Missing parameter " "sigcomp-id", "ParserCategory.cxx.ixx.temp", 126); } return p->value(); };

addTransport_Param::DType& ParserCategory::param(const addTransport_Param& paramType) { checkParsed(); addTransport_Param::Type* p = static_cast<addTransport_Param::Type*>(getParameterByEnum(ParameterTypes::addTransport)); if (!p) { p = new addTransport_Param::Type(ParameterTypes::addTransport); mParameters.push_back(p); } return p->value(); } const addTransport_Param::DType& ParserCategory::param(const addTransport_Param& paramType) const { checkParsed(); addTransport_Param::Type* p = static_cast<addTransport_Param::Type*>(getParameterByEnum(ParameterTypes::addTransport)); if (!p) { InfoLog(<< "Missing parameter " "addtransport" ); DebugLog(<< *this); throw Exception("Missing parameter " "addtransport", "ParserCategory.cxx.ixx.temp", 128); } return p->value(); };
