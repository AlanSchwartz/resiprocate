<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<rfc ipr="full2026" docName="draft-ietf-simple-msrp-relays-00.txt">
<front>
    <title abbrev="MSRP Relays">
        Relay Extensions for Message Sessions Relay Protocol (MSRP)
    </title>
    <author initials="C." surname="Jennings" fullname="Cullen Jennings">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>170 West Tasman Dr.</street>
          <street>MS: SJC-21/2</street>
          <city>San Jose</city> 
          <region>CA</region> <code>95134</code>
          <country>USA</country>
        </postal>
        <phone>+1 408 527-9132</phone>
        <email>fluffy@cisco.com</email>
      </address>
    </author>
    <author initials="R." surname="Mahy" fullname="Rohan Mahy">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>5617 Scotts Valley Drive, Suite 200</street>
          <city>Scotts Valley</city> <region>CA</region> <code>95066</code>
          <country>USA</country>
        </postal>
        <email>rohan@cisco.com</email>
      </address>
    </author>
    <date month="April" day="20" year="2004" />
    <area>Applications</area>
    <workgroup>SIMPLE WG</workgroup>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>MSRP</keyword>
    <abstract>
      <t>
The SIMPLE Working Group uses two separate models for conveying instant messages.  Pager-mode messages stand alone, whereas Session-mode messages are setup as part of a session using the SIP protocol. MSRP (Message Sessions Relay Protocol) is a protocol for near-real-time, peer-to-peer exchange of binary content without intermediaries, which is designed to be signaled using a separate rendezvous protocol such as SIP.  This document introduces the notion of message relay intermediaries to MSRP and describes the extensions necessary to use them.          
</t>
    </abstract>
  </front>
  <middle>
    <section title="Conventions and Definitions">
      <t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
  "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
  interpreted as described in <xref target="RFC2119">RFC-2119</xref>.
</t><t>
Below we list several definitions important to MSRP:
<list style="hanging">
<t>
<spanx style="strong">MSRP node:</spanx> A host that implements the MSRP protocols as a Client or a Relay
</t><t>
<spanx style="strong">MSRP Client:</spanx> A MSRP role which is the initial sender or final target of messages and delivery status.
</t><t>
<spanx style="strong">MSRP Relay:</spanx> A MSRP role which forwards messages and delivery status and may provide policy enforcement.  Relays MAY fragment and reassemble portions of messages.
</t><t>
<spanx style="strong">Message-Taker:</spanx> A MSRP Client which persistently stores messages on behalf of specific users or resources
</t><t>
<spanx style="strong">message:</spanx> arbitrary MIME content which one client wishes to send to another. For the purposes of this specification, a complete MIME body as opposed to a portion of a complete message.
</t><t>
<spanx style="strong">message fragment:</spanx> a portion of a complete message carried in (for example) a message/byteranges MIME type.
</t><t>
<spanx style="strong">message:</spanx> binary MIME content of an arbitrary type. Each message has a unique message-id.  In MSRP, messages may be broken up into pieces and sent in separate SEND requests.
</t><t>
<spanx style="strong">end-to-end:</spanx> delivery of data from the initiating client to the final target client
</t><t>
<spanx style="strong">hop:</spanx> delivery of data between one MSRP node and an adjacent node.
</t><t>
<spanx style="strong">transaction:</spanx> a request and response as seen from a single MSRP node.  Each transaction has a locally significant transaction identifier.
</t></list>
</t>
</section>

<section title="Introduction and Requirements">
<t>
The IETF SIMPLE Working Group has identified a number of scenarios where using a
separate protocol for bulk messaging is desirable. In particular, the SIMPLE WG
will use this facility to handle a sequence of messages as a session of media initiated using <xref target="RFC3261">SIP</xref>, just
like any other media type.  (The benefits of the session-mode approach are further discussed in <xref target="I-D.mahy-simple-why-session-mode"/>.) 
The SIMPLE Working Group has also developed MSRP (the Message Sessions Relay Protocol) to convey sessions of messages directly between two end systems with no intermediaries.  With MSRP, messages can be arbitrarily large and all traffic is sent over reliable, congestion-safe transports.
</t>
<t>
This document describes extensions to the core MSRP protocol to introduce intermediaries called Relays.  With these extensions MSRP clients can communicate directly, or through an arbitrary number of relays.  Each client is responsible for identifying any relays acting on its behalf and providing appropriate credentials.  Clients which can receive new TCP connections directly do not have to implement any new functionality to work with these relays.
 </t>
<t>
The Goals of the MSRP Relay extensions are listed below:
<list style="symbols">
<t> convey arbitrary binary MIME data without modification or transfer encoding
</t><t> continue to support client to client operation (no relay servers required)
</t><t> operate through an arbitrary number of relays for policy enforcement
</t><t> allow each client to control which relays are traversed on its behalf
</t><t> prevent unsolicited messages (spam), "open relays", and denial of
service amplification
</t><t> allow relays to use one or a small number of TCP or <xref target="RFC2246">TLS</xref> connections to
carry messages for multiple sessions, recipients, and senders
</t><t> allow large messages to be sent over a slow connection without causing
head-of-line blocking problems
</t><t> allow transmission of a large message to be interrupted and resumed in
place when network connectivity is lost and later reestablished
</t><t> offer notification of message failure at any intermediary
</t><t> provide notification of message storage (desirable)
</t><t> allow relays to delete state after a short amount of time
</t></list>
</t>
</section>

<section title="Protocol Overview">
<t>
With the introduction of this extension, MSRP has the concept of both clients and relays.  Clients send messages to relays
and/or other clients.  Relays forward messages and message delivery status to
clients and other relays.  Clients which can open TCP connections to each other
without intervening policy restrictions, can communicate directly with each
other.  Clients who are behind a firewall or who need to use an intermediary for
policy reasons can use the services of a relay.  Each client is responsible for
enlisting the assistance of one or more relays for its half of the
communication. 
</t>
<t>
We also define the special role of a Message-Taker, which is a client that
can receive messages and store them persistently on behalf of a user.  Note that
these roles can be co-resident. 
</t><t>
Clients which use a relay operate by first opening a connection with a relay,
authenticating, and retreiving a URI on the relay the client can provide to its peers to receive messages later.  
When a client uses a relay, it first opens a TLS connection to its first relay and authenticates using an AUTH request which can contain <xref target="RFC2617">HTTP Digest or Basic</xref> Authentication credentials.  In a successful AUTH response, the relay provides an MSRP URI associated with the path back to the client that the client can give to other clients for end-to-end message delivery.
</t><t>
When clients wish to send a short message, they send a SEND request with the
entire contents of the message. If any relays are required, they are included in the To-Path header. The leftmost URI in the To-Path header is the next hop to deliver a request or response.  The rightmost URI in the To-Path header is the final target.
</t>
<figure><artwork><![CDATA[
 MSRP SEND
 Tr-ID: 892341
 To-Path: msrp:example.org:9000/kjfjan \
  msrp:magic-coookie@example.net:9000/aeiug \ 
  msrp:bob.example.net:8145/foo
 From-Path: msrp:alice.example.com:7965/bar
 Boundary: 6aef
 Content-Type: text/plain

 Hi Bob, I'm about to send you LoTR.mpeg
 -------6aef$
 
 
 MSRP 200 OK
 Tr-ID: 892341
 To-Path: msrp:alice.example.com:7965/bar
 From-Path: msrp:example.org:9000/kjfjan
 
 MSRP SEND
 Tr-ID: 132452
 To-Path: msrp:magic-coookie@example.net:9000/aeiug \ 
  msrp:bob.example.net:8145/foo
 From-Path: msrp:example.org:9000/kjfjan \
  msrp:alice.example.com:7965/bar
 Boundary: 6aef
 Content-Type: text/plain

 Hi Bob, I'm about to send you LoTR.mpeg
 -------6aef$

 MSRP 200 OK
 Tr-ID: 132452
 To-Path: msrp:example.org:9000/kjfjan
 From-Path: msrp:magic-coookie@example.net:9000/aeiug

 MSRP SEND
 Tr-ID: 0987231
 To-Path: msrp:bob.example.net:8145/foo
 From-Path: msrp:magic-coookie@example.net:9000/aeiug \ 
  msrp:example.org:9000/kjfjan \
  msrp:alice.example.com:7965/bar
 Boundary: 6aef
 Content-Type: text/plain

 Hi Bob, I'm about to send you LoTR.mpeg
 -------6aef$

 MSRP 200 OK
 Tr-ID: 0987231
 To-Path: msrp:magic-coookie@example.net:9000/aeiug 
 From-Path: msrp:bob.example.net:8145/foo
 
 MSRP REPORT
 Tr-ID: 784333
 To-Path: msrp:magic-coookie@example.net:9000/aeiug \ 
  msrp:example.org:9000/kjfjan \
  msrp:alice.example.com:7965/bar
 From-Path: msrp:bob.example.net:8145/foo
 Receipt: success

 MSRP REPORT
 Tr-ID: 784333
 To-Path: msrp:example.org:9000/kjfjan \
  msrp:alice.example.com:7965/bar
 From-Path: msrp:magic-coookie@example.net:9000/aeiug \ 
  msrp:bob.example.net:8145/foo
 Receipt: success

 MSRP REPORT
 Tr-ID: 784333
 To-Path: msrp:alice.example.com:7965/bar
 From-Path: msrp:example.org:9000/kjfjan \
  msrp:magic-coookie@example.net:9000/aeiug \ 
  msrp:bob.example.net:8145/foo
 Receipt: success

 MSRP 200 OK
 Tr-ID: 784333
 To-Path: msrp:example.org:9000/kjfjan \
  msrp:magic-coookie@example.net:9000/aeiug \ 
  msrp:bob.example.net:8145/foo
 From-Path: msrp:alice.example.com:7965/bar
 Receipt: success

 MSRP 200 OK
 Tr-ID: 784333
 To-Path: msrp:magic-coookie@example.net:9000/aeiug \ 
  msrp:bob.example.net:8145/foo
 From-Path: msrp:example.org:9000/kjfjan \
  msrp:alice.example.com:7965/bar
 Receipt: success

 MSRP 200 OK
 Tr-ID: 784333
 To-Path: msrp:bob.example.net:8145/foo
 From-Path: msrp:example.org:9000/kjfjan \
  msrp:magic-coookie@example.net:9000/aeiug \ 
  msrp:alice.example.com:7965/bar
 Receipt: success

]]></artwork></figure>
<figure><artwork><![CDATA[
                    Typical flow involving two relays

Alice              a.example.org       b.example.net             Bob
  |                     |                    |                     |
  |::::::::::::::::::::>| connection opened  |<::::::::::::::::::::|
  |--- AUTH ----------->|                    |<-- AUTH ------------|
  |<-- 401 Auth---------|                    |--- 401 Auth-------->|
  |--- AUTH ----------->|                    |<-- AUTH ------------|
  |<-- 200 OK-----------|                    |--- 200 OK---------->|
  |                     |                    |                     |
        ....                time passes           ....
  |                     |                    |                     |
  |--- SEND ----------->|                    |                     |
  |<-- 200 OK ----------|:::::::::::::::::::>|  (slow link)        |
  |                     |--- SEND ---------->|                     |
  |                     |<-- 200 OK ---------|--- SEND ----------->|
  |                     |                    |                ....>|
  |                     |                    |                  ..>|
  |                     |                    |<-- 200 OK ----------|
  |                     |                    |<-- REPORT ----------|
  |                     |<-- REPORT ---------|                     |
  |<-- REPORT ----------|                    |                     |
  |--- 200 OK --------->|                    |                     |
  |                     |--- 200 OK -------->|                     |
  |                     |                    |--- 200 OK --------->|
  |                     |                    |                     |
]]></artwork></figure>
<t>
SEND requests are sent hop-by-hop.    
(Each relay that receives a SEND request
acknowledges receipt of the request before forwarding the content in other SEND requests.)  
All other requests are sent end-to-end. 
</t><t>
With the introduction of relays, the subtle semantics of the To-Path and From-Path header becomes more relevant.

The To-Path in both requests and responses is the list of URIs that need to be visited in order to reach the final target of the request.  The From-Path is the list of URIs that indicate how to get back to the original sender of the request or response (Note these semantics are slightly different for SEND requests). 

This differs from the To and From headers in SIP, which do not "swap" from request to response.

(Note that sometimes a request is sent to or from an intermediary directly.)

When a relay forwards a request, it removes its address from the To-Path header and inserts it at as the first URI in the From-Path header.  For example if the path from Alice to Bob is through relays A and B, when B receives the request it contains path headers that look like this:
</t>
<figure><artwork>
To-Path: msrp:B msrp:Bob
From-Path: msrp:A msrp:Alice
</artwork></figure>
<t>
after forwarding the request, the path headers look like this:
</t>
<figure><artwork>
To-Path: msrp:Bob
From-Path: msrp:B msrp:A msrp:Alice
</artwork></figure>
<t>
MSRP Nodes respond to SEND requests by taking the first URI form the From-Path and placing that in a To-Path header in the response, and placing their URI in the From-Path of the response.  MSRP Nodes response to all other requests which are addressed to their node by swapping the To-Path and From-Path headers.
</t><t>
When sending large content the client may split up a messsage into smaller pieces;
each SEND request might contain only a portion of the complete message.  [To avoid
confusion and ambiguity, each request or response is called a "parcel".]  For example, when
Alice sends Bob a 4GB file called "LoTR.mpeg", she sends
several SEND requests each with a portion of the complete message.
Relays can repack message fragments en-route.  As individual parts of the complete message arrive at the final destination client, the receiving client can optionally send REPORT requests indicating delivery status.
</t>
<t>
MSRP nodes can send individual portions of a complete message in multiple SEND requests.  Each parcel uses the message/byteranges MIME type
defined in <xref target="RFC2616">RFC 2616</xref> to correlate that part to the complete message.  As each SEND request is
received, the next hop acknowledges the request. As relays receive parcels they
can reassemble or re-fragment them as long as each chunk is sent in order.
Once a chunk or complete message arrives at the destination client, the
destination can optionally send a REPORT request indicating that a chunk arrived end-to-end.
This request travels back along the reverse path of the SEND request.  Unlike
the SEND request which is acknowledged along every hop, only the sender of
the REPORT request responds to an REPORT.  Relays then forward the REPORT
response back to the recipient of the original SEND.  
</t>
<figure><artwork><![CDATA[
               Flow involving re-chunking through two relays

Alice              a.example.org       b.example.net             Bob
  |                     |                    |                     |
  |                     |                    |                     |
  |--- AUTH ----------->|                    |<-- AUTH ------------|
  |<-- 401 Auth---------|                    |--- 401 Auth-------->|
  |--- AUTH ----------->|                    |<-- AUTH ------------|
  |<-- 200 OK-----------|                    |--- 200 OK---------->|
  |                     |                    |                     |
        ....                time passes           ....
  |                     |                    |                     |
  |--- SEND 0-3 ------->|                    |                     |
  |<-- 200 OK ----------|                    |  (slow link)        |
  |--- SEND 4-7 ------->|--- SEND 0-5 ------>|                     |
  |<-- 200 OK ----------|<-- 200 OK ---------|--- SEND 0-3 ------->|
  |--- SEND 8-10 ------>|--- SEND 6-10 ----->|                ....>|
  |<-- 200 OK ----------|<-- 200 OK ---------|                  ..>|
  |                     |                    |<-- 200 OK ----------|
  |                     |                    |<-- REPORT 0-3 ------|
  |                     |<-- REPORT 0-3 -----|--- SEND 4-7 ------->|
  |<-- REPORT 0-3 ------|                    |                 ...>|
  |--- 200 OK --------->|                    |                  ..>|
  |                     |--- 200 OK -------->|                     |
  |                     |                    |--- 200 OK --------->|
  |                     |                    |<-- REPORT 4-7 ----->|
  |                     |<-- REPORT 4-7 -----|--- SEND 8-10 ------>|
  |<-- REPORT 4-7 ------|                    |                  ..>|
  |--- 200 OK --------->|                    |<-- 200 OK ----------|
  |                     |<-- REPORT done-----|<-- REPORT done -----|
  |<-- REPORT done -----|--- 200 OK -------->|                     |
  |--- 200 OK --------->|                    |--- 200 OK --------->|
  |                     |--- 200 OK -------->|                     |
  |                     |                    |--- 200 OK --------->|
  |                     |                    |                     |
]]></artwork></figure>
<t>
Relays only keep transaction state for a short period of time for each chunk.  Delivery of each hop should take no more than 32 seconds after the last byte of data is sent.  Clients applications define their own implementation-dependent timers for
end-to-end message delivery.
</t>
<t>
In some cases the end user node may not have its own client or that client or
node may be unavailable. In this case, a message-taker can take receipt of the
message or fragment and deliver a REPORT back to the sender indicating that the
message or fragment was successfully stored.
</t>
<t>
For client to client communication, the sender of a message typically opens a
new TCP connection (with or without TLS) if one is needed.  Relays reuse existing connections first,
but can open new connections (typically to another relay) to deliver SEND
or REPORT requests.
</t>
</section>

<section title="New Protocol Elements">
<section title="The AUTH Method">
<t>
AUTH requests are used by clients with ephemeral addresses to create a
handle they can use to receive incoming requests.  AUTH requests can also
contain credentials used to authenticate a client, and authorization policy used
to block Denial of Service attacks.  AUTH requests are discussed in more detail in Section XXX TODO.
</t><t>
In response to an AUTH request, a successful response contains a Path header with a list of URIs that the Client can give to its peers to route responses back to the Client. 
</t>
</section>

<section title="The Use-Path header">
<t>
    TBD
</t>
</section>

<section title="Authentication headers">
<t>
The Authentication-Info header provides optional information for HTTP Digest authentication.  This header MAY be included in the response to an AUTH request.  Semantics of the header are described in RFC 2617
</t><t>
The Authorization header contains authentication credentials for HTTP Digest authentication in an AUTH request. Section [x.y] .   Note that the parameters of this header are separated by commas instead of semicolons.  The presence of commas in this header does not imply that there is more than one header field value for this header field (only one header field value is allowed). Semantics of the header are described in RFC 2617.  This header MUST NOT appear in any parcel other than an AUTH request.
</t><t>
The WWW-Authenticate header [more]
</t>
</section>

<section title="Time-related headers">
<t>
The Expires header in a provides a relative time after which the action implied by the method of the request is no longer of interest.  In a request, the Expires header indicates how long the sender would like to .  In a response, the Expires header indicates how long the responder considers this information relevant (if the responder [more].  Specifically an Expires header in an AUTH request indicates how long the provided URIs will be valid.
</t><t>
The Min-Expires header contains the minimum duration a server will permit in an Expires header.  It is sent only in 423 "Interval Too Brief" responses.
</t><t>
423 Interval Out-of-bounds.  Max-Expires header
</t>
</section>
</section>

<section title="Procedures">
<section title="Client behavior">
<section title="Connecting to relays acting on your behalf">
<t>
Clients which want to use the services of a relay or list of relays, need to send an AUTH request to each relay which will act on their behalf. For example, some organizations could deploy an "intra-org" relay and an "extra-org" relay.  A client using these relays opens a connection to the intra-org relay and sends an AUTH request.  response
</t><t>
Clients can be configured (typically through discovery or manual provisioning) with a list of relays
they need to use. They MUST be able to form a connection to each relay and send
an AUTH command to get a URI that can be used in route headers. The client can
authenticate the relay by looking at the relay's TLS certificate. The relay MUST
authenticate the client using digest authentication. 
</t><t>
The relay will return a URI, or list of URIs, in the Use-Path header of the
response. When using a session-protocol such as SIP, these URIs are used by the client in the path attribute that is sent in
the SDP to setup the session. The same URI can be used for multiple sessions to
send to the client. 
</t><t>
<t>
When sending an AUTH request, the client MAY add an Expires header to request a MSRP URI that is valid for no longer that the provided interval.  If an AUTH request returns a 401 Unauthorized request, the client SHOULD fetch the Digest challenge from the WWW-Authenticate header in the response and retry the AUTH request, including an Authorization header with the Digest response.  Unlike in HTTP and SIP, Digest authentication in MSRP is only permitted for AUTH requests.
</t>
Example with two relays on one side. Need to AUTH to first, then use the
supplied route header to AUTH to second thought the first. 
</t><t> 
NOTE - only auth not auth-int is needed because TLS provides integrity 
</t><t>
When a client wishes to use more than one relay, they must AUTH to each relay
they wish to use. Consider a client A, that whishes messages to flow from A to
the first relays, R1, then on to a second relays, R2. This client with do a
normal AUTH with R1. It will then do an AUTH transaction with R2 that is routed
through R1. The client will form this AUTH messages by setting the request URI
to R2 and adding a route header with the URI learned from R1 then sending this
message to R1. R1 will forward this like a REPORT request is forwarded to
R2. 
</t><t>
When the client sends an AUTH request, it may set the Expires header a relative
time. The relay will return a URI that is only valid for that periods of
time. 
</t>
<figure><artwork><![CDATA[
auth to-path: intra-org
     from-path: alice@a
200  to-path: alice@a
     from-path: intra-org
     use-path: alice@intra-org/abcd alice@a

auth to-path: alice@intra-org/abcd extra-org
    auth to-path: extra-org
    200 use-path: extra-org/xyzpdq alice@intra-org/abcd alice@a
200 use-path: extra-org/xyzpdq alice@intra-org/abcd alice@a
]]></artwork></figure>
</section>    
<section title="Sending requests">
<t>
The procedure for sending SEND, VISIT, and REPORT requests is identical for clients whether relays are involved or not. The specific procedures are described in section TODO of [MSRP].
</t><t>
As usual, once the next-hop URI is determined, the client MUST find the appropriate address, port, and transport to use and then check if there is already an existing suitable connection to the next-hop target.  If so, the client MUST send the request over the most suitable connection.  Suitability MAY be determined by a variety of factors such as measured load and local policy, however in most simple implementations a connection will be suitable if it exists and is in an active state.
</t>
</section>

<section title="Receiving Requests">
<t>
The procedure for receiving requests is identical for clients whether relays are involved or not.
</t>
</section>

<section title="Managing Connections">
<t>Clients should open connection whenever they wish to deliver a request and no suitable connection exists.  For client to client connections, a client should close a connection when there are no longer any sessions associated with the connection.  For connections to relays, the client should leave a connection up until no sessions are using the connection for a locally defined period of time, which defaults to 5 minutes for foreign relays and one hour for the client's relays.</t>
</section>
</section>

<section title="Relay behavior">
<section title="Handling Incoming Connections">
<t>
    
</t>
</section>
<section title="Generic request behavior">
<t>
Upon receiving a new request, relays first verify the validity of the request.

[NO: Relays then tag valid requests with a locally-significant connection identifier which they add to the last URI in the Back-Path header.  This is used to insure that responses can be routed over an existing connection.  ???]
     
Relays then examine the first URI in the To-Path header and remove this URI if it matches a URI corresponding to the relay. 
Authorization -- determine if the final target is a URI under its control or from a URI under its control.
</t>
</section>

<section title="Receiving AUTH requests">
<t>
When a relay receives an AUTH request, it must digest challenge the
request. Once the challenge is complete, it MUST provide a URI that can be used
in future route headers. When the route URI is received in future messages. It
MUST verify that this URI was issues by this relay. It MUST ensure that the
message is either being forwarded from an entity that did the AUTH request that
resulted in this URI or it is being forwarded to the the entity that did the
AUTH request that resulted in this URI.  </t>
<t>
Discuss forwarding of AUTH requests for another relay
</t>
<t>
The relay does not necessarily needs to save state to meet these
requirements. One way that a relay could implement this is the following. When
an AUTH request arrives, the relay concatenates the current time, the identity
of the sender of the AUTH request, the identity of the previous hop the request
came from. It then takes the concatenates string and encrypts it with a key only
the relay knows and uses this for form the user portion of the sims URI that it
returns.  Later when it receives a URI, it can decrypt this information and use
it to decide if the request should be forwarded or not.  If the relay is
actually several servers that share a DNS name, the URI may also encrypt which
server actually has the connection to the client. </t>
<t>
When a relay receive an AUTH request, it must authenticate the client that sent
it with digest, it must also authenticate the previous hop that send the message
to it. When previous hop was a relay this is done with the mutual TLS while when
the previous hop was a client mutual TLS MAY be used it is available or the
client authorization from the digest is used. The relay will generate the base URI of a family of URIs, each of which
allows messages to be forwarded to and from this client. If the
previous hop was authenticated by mutual TLS, then the URI MUST be valid to
route across any connection the relay has to the previous hop relay. If the
previous hop was not authenticated by mutual TLS, then the URI MUST only be
valid to route across the same connection that the AUTH was received on. If this
connection is closed then reopened, the URI MUST NOT be valid. Valid to route
means that when the relay receives a messages that contains this URI, if the
message it going to element that was the previous hop in the AUTH, then the
relay can forward it and if the messages is coming from previous hop in the
AUTH, then the relay can forward it to any location, otherwise the RELAY must
discard the message and MAY send a REPORT indicating the auth URI was bad. If
the AUTH request contains an Expires header, then the relay MUST ensure that the
URI is not valid to route after the expiry time. 
</t><t>
    [*** NOTE: Consider moving to another section ***]
</t><t>
It is possible to implement all of the above requirements without the relay
saving any state. When a relay starts up it could pick a crypto random 128 bit
password (K) and 128 bit initialization vector (IV). If the relay was actually a
NDS farm, all the machines in the farm would need to share the same K. When an
ATUH request was received the relay form a string that contains: the expiry time
of the URI, an indication if the previous hop was mutual TLS authenticated or
not and it it was, the name of the previous hop, if it was not the identifier
for the connection which received the AUTH request. This string would be padded by appending a byte with the value 0x80 then adding zero or more bytes with the value of 0x00 until the string length is a multiple of 16 bytes long.  A new random IV vector would be
selected (it needs to change because it forms the salt) and the padded string would
be encrypted using AES-CBC with a key of K. The IV and encrypted data and an SPI (security parameter index) that changed each time K changed would be
base 64 encoded and form the user portion of the request URI. The SPI allows the key to be changed and for the system to know which K should be used. Later when the
relay received this URI, it could decrypt it and check the current time was
before the expiry time and check that the messages was coming from or going to
the connection or location specified in the URI. Integrity protection is not required because it is extremely unlikely that random data that was decrypted would result in a valid location that was the same as the messages was routing to or from.  When implementing something
like this, implementers should be careful not to use a scheme like EBE that
would allows portion of encrypted tokens to be cut and paste into others.
</t><t>
Note: A successful AUTH response returns a Route header which contains a base MSRP URI that the 
  client can use to create a number of different URIs which are all associated with the current connection.
</t>
</section>

<section title="Forwarding SEND requests">
<t>
A MSRP relay that receives a SEND request MUST respond with a final response
immediately. A 200-class response indicates the successful receipt of a
message fragment, but does not mean that the message has been forwarded on to
its next hop. 
</t><t>
The final response to the SEND MUST be sent to the previous hop, which could
be a MSRP relay or the original sender of the SEND request. 
</t><t>
The 2xx response to the SEND MUST NOT contain a body. A 4xx or 5xx response
indicates that the message was not delivered successfully.  A 6xx response means
it was delivered successfully, but refused.
</t><t>
The MSRP relay MAY further break up the message fragment received in the SEND
request into smaller fragments and forward them to the next hop in separate
SEND requests. It MAY also combine message fragments received before or after
this SEND request, and forward them out in a single SEND request to the
next hop identified in the Hops header. The MSRP relay MUST NOT combine message
fragments from SEND requests with different values in the Message-ID header.
</t><t>
The MSRP relay MAY choose whether to further fragment the message, or combine
message fragments, or send the message as is, based on some policy which is
administered, or based on the network speed to the next hop, or any other
mechanism.
</t><t>
If the MSRP relay has knowledge of the byte range that it will transmit to the
next hop, it SHOULD update the message/byteranges parameter in the SEND
request appropriately.
</t><t>
Before forwarding the SEND request to the next hop, the MSRP relay MUST
inspect the first URI in the To-Path header. If it indicates this
relay, the relay removes this URI from the To-Path header and inserts this URI in the From-Path header before any other URIs. 
</t><t>
If the MSRP relay fails to forward the SEND on to the next hop, it SHOULD
return a REPORT back to the sender of the SEND indicating the reason for
failure using the list of URIs in the From-Path header.  [how?  example.  see section]
</t>
</section>



<section title="Forwarding non-SEND requests">
<t>
An MSRP relay that receives any request other than a SEND request (including new methods unknown to the relay), first follows the validation and authorization rules for all requests in Section x.y. Then the relay moves its URI from the beginning of the To-Path header, to the beginning of the From-Path header and forwards the request on to the next hop.

It MUST use the most suitable conection, etc, etc..  If no suitable connection exists, the relay opens a new connection.
    
    
</t>
</section>

<section title="Forwarding Responses">
<t>
    Relays receiving a response, first check the Tr-ID of the response.  If the relay is unaware of this transaction, the response MUST be dropped. Likewise if the message is unparsable, the relay MUST drop the response.  If the response matches an existing transaction, the transaction state MUST be deleted. The relay MUST verify that the first URI in the To-Path corresponds to it. If not, the response SHOULD be dropped. If there are additional URIs in the To-Path header, the relay can then move its URI from the list To-Path header, insert its URI in front of any other URIs in the From-Path header, and forward the response to the next URI in the To-Path header.  The relay sends the request over the best connection which corresponds to the next URI in the To-Path header.  If this connection has closed, then the response is silently discarded.
</t>
</section>

<section title="Managing Connections">
<t>
Relays should keep connection open as long as possible. If a connection has not
been used in a significant time (many minutes) it could be closed. If the relay
runs out of resource and must close connections, it should first stop accepting
new connections from clients then start closing connections on a least recently
used basis. </t>
</section>

<section title="Forwarding unknown requests">
<t>
Requests with an unknown method are forwarded as if they were REPORT requests.
</t>
</section>
</section>

<section title="Acting as a Message Taker">
<t>
A Message Taker merely acts like a Client which returns different REPORT
responses. </t>
<t>
TODO - how do I let the message taker know to send all the requests it saved
for me to me. I assume I still send REPORTs to the original sender as well as the
message take to let them know I got the message. </t>
</section>
</section>

<section title="Formal Syntax">
<t>
The following syntax specification uses the augmented Backus-Naur Form (BNF) as
described in <xref target="RFC2234">RFC-2234</xref>.  
</t>
<figure><artwork>
<![CDATA[
AUTHm           = %x41.55.54.48           ; AUTH in caps
Method          = SENDm / VISITm / REPORTm / AUTHm
                     / extension-method

             /   "401"  ;  Authentication Required
             /   "423"  ;  Interval Out-of-Bounds
             


Authentication-Info  =  "Authentication-Info" HCOLON ainfo
                        *(COMMA ainfo)
ainfo                =  nextnonce / message-qop
                         / response-auth / cnonce
                         / nonce-count
nextnonce            =  "nextnonce" EQUAL nonce-value
response-auth        =  "rspauth" EQUAL response-digest
response-digest      =  LDQUOT *LHEX RDQUOT

Authorization     =  "Authorization" HCOLON credentials
credentials       =  ("Digest" LWS digest-response)
                     / other-response
digest-response   =  dig-resp *(COMMA dig-resp)
dig-resp          =  username / realm / nonce / digest-uri
                      / dresponse / algorithm / cnonce
                      / opaque / message-qop
                      / nonce-count / auth-param
username          =  "username" EQUAL username-value
username-value    =  quoted-string
digest-uri        =  "uri" EQUAL LDQUOT digest-uri-value RDQUOT
digest-uri-value  =  rquest-uri ; Equal to request-uri as specified
                     by HTTP/1.1
message-qop       =  "qop" EQUAL qop-value
cnonce            =  "cnonce" EQUAL cnonce-value
cnonce-value      =  nonce-value
nonce-count       =  "nc" EQUAL nc-value
nc-value          =  8LHEX
dresponse         =  "response" EQUAL request-digest
request-digest    =  LDQUOT 32LHEX RDQUOT
auth-param        =  auth-param-name EQUAL
                     ( token / quoted-string )
auth-param-name   =  token
other-response    =  auth-scheme LWS auth-param
                     *(COMMA auth-param)
auth-scheme       =  token
LHEX              =  DIGIT / %x61-66 ;lowercase a-f
;   Some elements (authentication) force hex alphas to be lower case.

WWW-Authenticate  =  "WWW-Authenticate" HCOLON challenge
challenge           =  ("Digest" LWS digest-cln *(COMMA digest-cln))
                       / other-challenge
other-challenge     =  auth-scheme LWS auth-param
                       *(COMMA auth-param)
digest-cln          =  realm / domain / nonce
                        / opaque / stale / algorithm
                        / qop-options / auth-param
realm               =  "realm" EQUAL realm-value
realm-value         =  quoted-string
domain              =  "domain" EQUAL LDQUOT URI
                       *( 1*SP URI ) RDQUOT
URI                 =  MSRP-URI / anyURI
nonce               =  "nonce" EQUAL nonce-value
nonce-value         =  quoted-string
opaque              =  "opaque" EQUAL quoted-string
stale               =  "stale" EQUAL ( "true" / "false" )
algorithm           =  "algorithm" EQUAL ( "MD5" / "MD5-sess"
                       / token )
qop-options         =  "qop" EQUAL LDQUOT qop-value
                       *("," qop-value) RDQUOT
qop-value           =  "auth" / token
]]></artwork></figure>
</section>

<section title="Finding MSRP Servers" anchor="srv">
<t>
    ### FIX ENTIRE SECTION ###
</t>
<t>
When sending a response, the response is always forwarded over an existing
connection using the connection handle set in the receiver parameter in the
topmost Via header field value and the sent-by transport in that Via header
field value to determine the correct connection.
</t>
<t>
When resolving a URI (for example from a Route header field, or from the
Request-URI), examine the hostport portion of the URI and the transport URI
parameter to decide how to proceed.
</t>
<t>
If the hostport is an IPv4 address or an IPv6 reference, send the request to
that address using the port and transport specified in the URI. If no transport
is provided, use the default (tls+tcp).  If no port number is provided, use the
default for the selected protocol (port 8999 for tcp, and port 9000 for tls over
tcp).
</t>
<t>
If the hostport is a domain name and an explicit port number is provided,
attempt to lookup a valid address record (A, AAAA, or A6) for the domain name.
Connect using the specified protocol (or the default of tls+tcp if none is
specified) and port number. </t>
<t>
If a domain name is provided, but no port number, perform a <xref target="RFC2782">DNS SRV</xref> lookup for
all transports supported by the client and select the entry with the highest
weight.  If no SRV records are found, try an address lookup using the default
port number procedures described in the previous paragraph. Note that AUTH
requests MUST only be sent over a TLS-protected channel.  An SRV lookup in the
example.com domain might return: </t>
<figure><artwork>
;; in example.com.      Pri Wght Port Target   
_sims+tls._tcp   IN SRV 0   1    9000 server1.example.com.
_sims+tls._tcp   IN SRV 0   2    9000 server2.example.com.
_sims._tcp       IN SRV 1   1    8999 server1.example.com.
_sims._tcp       IN SRV 1   2    8999 server2.example.com.
</artwork></figure>
<t>
If implementing a relay farm, it is RECOMMENDED that each member of the relay
farm have an SRV entry.  If any members of the farm have multiple IP addresses
(for example an IPv4 and an IPv6 address), each of these addresses SHOULD be
registered in DNS as separate A, AAAA, or A6 records corresponding to a single
target. </t>
</section>



<section title="Security Considerations">
<t>
This section first describes the security mechanisms available for use in
MSRP. Then the threat model is presented.  Finally we list implementation
requirements related to security.
</t>

<section title="Using HTTP Authentication">
<t>
AUTH requests SHOULD be authenticated using HTTP authentication.  HTTP
authentication is done as described in [RFC 2617], with the following
exceptions. Basic authentication MUST NOT be used. A qop value of auth-int MUST
NOT be used as the AUTH requests are integrity protected by TLS and there is no
body to protect. Note that unlike in some usages of HTTP Authentication (for
example, SIP), the uri parameter in the Authorize header is the same as the
Request-URI in the request line of the MSRP parcel of the AUTH request.  Note
the BNF in RFC-2617 has an error--the value of the uri parameter MUST be in
quotes. The BNF in this document is correct, as are the examples in RFC
2617.</t>
</section>

<section title="Using TLS">
<t>
TLS is used to authenticate relays to senders and to provide integrity and
confidentiality for the headers being transported. MSRP client and relays MUST
support TLS.  Clients and relays MUST support the TLS ClientExtendedHello
extended hello information for server name indication as described in <xref
target="RFC3546">RFC 3546</xref>. A TLS cipher-suite of
<xref target="RFC3268">TLS_RSA_WITH_AES_128_CBC_SHA</xref> MUST be supported
(other cipher-suites MAY also be suported). Relays must act as TLS servers and
present a certificate with their identity in the SubjectAltName using the choice
type of dnsName. Relay to relay connections MUST use TLS and client to relay
communications MUST use TLS for AUTH requests and responses.
</t>
</section>

<section title="Threat Model">
<t>
This section discuses the threat model and the broad mechanism that must come
into place to secure the protocol. The next section describes the details of how
the protocol mechanism meet the broad requirements.  </t>
<t>
MSRP allows two peer to peer clients to exchange messages. Each peer can select
a set of relays to perform certain policy operation for them. This combined set
of relays is referred to as the route set. There often exists a channel outside
of MSRP, such as out-of-band provisioning or an explicit rendezvous protocol
such as SIP, that can securely negotiate setting up the MSRP session and
communicate the route set to both clients. A client may trust a relay with
certain types of routing and policy decisions but it might or might not trust
the relay with all the contents of the session. For example, a relay being
trusted to look for viruses would probably need to be allowed to see all the
contents of the session. A relay that helped deal with firewall traversal of the
ISPs firewall would likely not be trusted with the contents of the session but
would be trusted to correctly forward information.  </t>
<t>
Clients need to be able to authenticate that the relay they are communicating
with is the one they trust. Likewise, relays need to be able to authenticate the
client is the authorized client for them to forward information to. Clients need
the option of ensuring information between the relay and the client is integrity
protected and confidential to elements other than the relays and clients. To
simplify the number of options, traffic between relays must always be integrity
protected and encrypted regardless of if the client request it or not. There is
no way for the clients to tell the relays what strength of crypto to use between
relays other than the clients to choose to use relays that are operated by
people requiring an adequate level of security. </t>
<t>
The system also need to stop the messages from being directed to relays that are
not supposed to see them. To keep the relays from being used in DDoS attacks,
the relays must not forward messages unless they have a trust relationship with
either the client sending or receiving the message and that they only forward
that message if it is coming from or going to the client they have the trust
relationship with. If a relay has a trust relationship with the client that is
the destination of the message, it should not send the message anywhere except
the client that is the destination. </t>
<t>
Some terminology used in this discussion is SClient is the client sending a
message and RClient is the client receiving a message. SRelay is a relay the
sender trusts and RRelay is a relay the receiver trusts. The message will go
from SClient to SRelay1 to SRelay2 to RRelay2 to RRelay1 to RClient.  </t>

</section>
<section title ="Security Mechanism ">

<t> Confidentiality and Privacy from elements not in the route set is provided
by using TLS on all the transports. If a client decided to not use TLS that is
it's choice but relays must use TLS. Clients must implement TLS. </t>
<t>
The relays authenticate to the clients using TLS (but don't have to do mutual
TLS). The clients authenticate to the relays using HTTP Digest inside of
TLS. Relays authenticate to each other using mutual TLS.</t>
<t>
The clients can protect the contents so that the relays can not see them by
using S/MIME encryption. End to end signing is also possible with S/MIME. </t>
<t>
The complex part is making sure that relays do not send messages place where
they should not. This is done by having the client authenticate to the relay and
having the relay return a token. Messages that contain this token can be relayed
if they come from the client that got the token or if they are being forwarded
towards the client that got the token. The tokens must only ever be seen by
things in the route set or other elements that at least one of the parties
trusts.  If some 3rd party discovers the token that RRelay2 uses to forward
messages to RClient, then that 3rd party can send as many messages as they want
to RRelay2 and it will forward them to RClient. The 3rd party can not cause them
to be forwarded anywhere except to RClient eliminating the open relay
problems. SRelay1 will not forward the message unless it contains a valid
token. </t>
<t>
When SClient goes to get a token from SRelay2, this request is relayed through
SRelay1. SRelay authenticates that it really is SClient requesting the token but
it generates a token that is only valid for forwarding messages to or from
SRelay1. SRelay two knows it is connected to SRelay1 because of the mutual
TLS. </t>
<t>
The tokens are carried in the user portion of the MSRP URLs.</t>
<t>
Issues: How to tokens expire - rekeying. Will probably use Expire header on AUTH
response. Token MAY be valid for between 10 minutes and 24 hours with 1 hour
recommended. Both sides need to do a SIP re-invite to set up new tokens before
the old one expires. </t>
<t>
Issues: Token good for single session or for all session </t>
<t>
Note: tokens are only required for relays, not clients or note takers. </t>
<t>
TODO talk about example from client to client and from Client A, then to a relay
that A uses, RA, then on to client B. </t>
</section>

<section title="Preventing Spam and Denial of Service Attacks">
<t>
While this specification already implements a number of significant improvements to prevent unsolicited messaging and Denial of Service, additional mechanisms are envisioned being useful in the future.  The 402 Payment Required and 409 Puzzle Required response codes are reserved for future use and may be useful to further discourage unsolicited messages.
</t>
</section>
</section>

<section title="IANA Considerations">
     <t>
This document introduces no requirements for IANA.
     </t>
    </section>
    

<section title="Example SDP with multiple hops">
<t>
A sample SDP offer for a MSRP session could look like:
</t>
<figure><artwork><![CDATA[
c=IN IP4 invalid.none
 m=message 1234 msrp/tcp alice@alice.example.com
 a=accept: message/cpim text/plain text/html
 a=hop:msrp:magic456@a.example.com:1234;transport=tcp
]]>
</artwork></figure>
<t>
In this offer Alice wishes to receive MSRP messages at
alice@alice.example.com. She wants to use TCP as the transport for the MSRP
session. She can accept message/cpim, text/plain and text/html message boldies
in SEND requests. She wishes to use the relay msrp:magic456@a.example.com for
the MSRP session.
</t><t>
To this offer, Bob's answer could look like:
</t>
<figure><artwork><![CDATA[
c=IN IP4 invalid.none
 m=message 1234 msrp/tcp bob@bob.example.com
 a=accept: message/cpim text/plain
 a=hop:msrp:magic789@b1.example.com:1234;transport=tcp
 a=hop:msrp:magic012@b2.example.com:1234;transport=tcp
]]>
</artwork></figure>
<t>
Here Bob has agreed to use tcp as the transport, and wishes to receive the
MSRP messages at bob@bob.example.com. He can accept only message/cpim and
text/plain message bodies in SEND requests and has rejected text/html offer
made by Alice. He wishes to use two relays for the MSRP session -
msrp:magic789@b1.example.com and msrp:magic012@b2.example.com.
</t>
</section>
</section>


<section title="Comparison with requirements and with MSRP">
<t>
TODO - Topics to compare: TCP fan out, HOL blocking, next hop congestion at a
relay, congestion back pressure, robust sending of a message even as host
temporarily disconnects and reconnects. scale, relay farms, multiple
relays, and congestion. 
</t>
</section>


<section title="Examples">

<section title="Client to Client with SIP">
<t>
In this example, Alice and Bob setup a MSRP session with the help of SIP. To
keep the example simple and easy to understand, there are no SIP proxies
shown. There are no MSRP relays which need to be traversed between Alice and
Bob. It also shows the session tear-down using a SIP BYE.
</t>
<figure><artwork><![CDATA[
        Alice                        Bob
          |                           |
          |                           |
          |---------INVITE (1)------->|
          |                           |
          |<------200 OK (2)----------|
          |                           |
          |----------ACK (3)--------->|
          |                           |
          |--------SEND (4)--------->|
          |                           |
          |<-------200 OK (5)---------|
          |                           |
          |<--------REPORT (6)--------|
          |                           |
          |---------200 OK (7)------->|
          |                           |
          |-----------BYE (8)-------->|
          |                           |
          |                           |

]]>
</artwork></figure>
<t>
1 INVITE Alice -> Bob (SIP) : Alice sends an INVITE to Bob to start an IM session, with an SDP offer for the session.</t>
<figure><artwork><![CDATA[

INVITE sip:bob@pc1.example.com SIP/2.0
Via: SIP/2.0/UDP pc2.atlanta.com;branch=z9hG4bKkjshdyff
To: Bob <sip:bob@pc1.example.com>
From: Alice <sip:alice@pc2.example.com>;tag=88sja8x
Max-Forwards: 70
Call-ID: 987asjd97y7atg
CSeq: 986759 INVITE
Content-Type: application/ sdp
Content-Length: 120

c=IN IP4 invalid.none
m=message 1234 sims/tcp+tls alice@pc2.example.com
a=accept-types:text/plain message/cpim

]]>
</artwork></figure>
<t>
2 200 OK Bob -> Alice (SIP): Bob responds with a 200 OK and an answer SDP. </t>
<figure><artwork><![CDATA[

SIP/2.0 200 OK
Via: SIP/2.0/UDP pc2.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
To: Bob <sip:bob@pc1.example.com>;tag=a6c85cf
From: Alice <sip:alice@pc2.example.com>;tag=88sja8x
Call-ID: 987asjd97y7atg
CSeq: 986759 INVITE
Content-Type: application/sdp
Content-Length: 131

c=IN IP4 invalid.none
m=message 1234 sims/tcp+tls bob@pc1.example.com
a=accept-types:text/plain 

]]>
</artwork></figure>
<t>
3 ACK Alice -> Bob (SIP): Alice sends an ACK to Bob and the session is
              successfully set up. Alice and Bob can now start sending messages
              to each other. </t>
<figure><artwork><![CDATA[

ACK sip:bob@pc1.example.com SIP/2.0
Via: SIP/2.0/UDP pc2.example.com;branch=z9hG4bKkjshdyff
To: Bob <sip:bob@pc1.example.com>;tag=a6c85cf
From: Alice <sip:alice@pc2.example.com>;tag=88sja8x
Max-Forwards: 70
Call-ID: 987asjd97y7atg
CSeq: 986759 ACK

]]>
</artwork></figure>
<t>
4 SEND Alice -> Bob (MSRP): Alice sends a SEND to Bob. This is a complete
                message. </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bKkjshdyff
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type: text/plain;boundary=-----bound123456

-------bound123456
Hi Bob, How are you?
-------bound123456

]]>
</artwork></figure>
<t>
5 200 OK Bob -> Alice (MSRP): Bob responds with a 200 OK to indicate successful
               delivery of the SEND. </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
6 REPORT Bob -> Alice (MSRP): Bob REPORTs Alice of the successful end-to-end
               delivery of the entire message. </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
Delivery-Status:ok
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
7 200 OK Alice -> Bob (MSRP): Alice responds with a 200 OK to indicate that it
                 has received the REPORT. </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
8 BYE Alice -> Bob (SIP): Alice sends a BYE to Bob to tear down the SIP
              session. </t>
<figure><artwork><![CDATA[

BYE sip:alice@pc2.example.com SIP/2.0
Via: SIP/2.0/UDP pc2.example.com;branch=z9hG4bKkjshdyff
Max-Forwards: 70
To: Bob <sip:bob@pc1.example.com>;tag=a6c85cf
From: Alice <sip:alice@pc2.example.com>;tag=88sja8x
Call-ID: 987asjd97y7atg
CSeq: 231 BYE
Content-Length: 0
]]>
</artwork></figure>
</section>
<section title="3 relays with SIP">
<t>
In this example, Alice has been configured to use two relays (r1.example.com and r2.example.com) for MSRP, and Bob has been configured with one relay (r3.example.com). Alice and Bob establish a TLS session with the relays and authenticate themselves, getting back the URIs for the relays that they should use in the Route headers of the MSRP messages.
</t>
<figure><artwork><![CDATA[
 Alice     r1.example.com    r2.example.com    r3.example.com   Bob
 |                |                |              |               |
 |                |                |              |               |
 |---AUTH (1)---->|                |              |<--AUTH (5)----|
 |                |                |              |               |
 |<------401 (2)--|                |              |------401 (6)->|
 |                |                |              |               |
 |---AUTH (3)---->|                |              |<--AUTH (7)----|
 |                |                |              |               |
 |<--200 OK (4)---|                |              |--200 OK (8)-->|
 |                |                |              |               |
 |--AUTH (9)----->|                |              |               |
 |                |                |              |               |
 |                |---AUTH (10)--->|              |               |
 |                |                |              |               |
 |                |<-401  (11)-----|              |               |
 |                |                |              |               |
 |<-401 (12)------|                |              |               |
 |                |                |              |               |
 |--AUTH (13)---->|                |              |               |
 |                |                |              |               |
 |                |---AUTH (14)--->|              |               |
 |                |                |              |               |
 |                |<--200 OK (15)--|              |               |
 |                |                |              |               |
 |<--200 OK (16)--|                |              |               |
 |                                                                |
 |                                                                |
 |----------------------------INVITE (17)------------------------>|
 |                                                                |
 |<----------------------------200 OK (18)------------------------|
 |                                                                |
 |-------------------------------ACK (19)------------------------>|
 |                                                                |
 |                |                |              |               |
 |--SEND (20)--->|                |              |               |
 |                |                |              |               |
 |<--200 OK (21)--|                |              |               |
 |                |                |              |               |
 |                |--SEND (22)--->|              |               |
 |                |                |              |               |
 |                |<--200 OK (23)--|              |               |
 |                |                |              |               |
 |                |                |--SEND (24)->|               |
 |                |                |              |               |
 |                |                |<-200 OK (25)-|               |
 |                |                |              |               |
 |                |                |              |--SEND (26)-->|
 |                |                |              |               |
 |                |                |              |<--200 OK (27)-|
 |                |                |              |               |
 |                |                |              |<--REPORT (28)-|
 |                |                |              |               |
 |                |                |<-REPORT (29)-|               |
 |                |                |              |               |
 |                |<--REPORT (30)--|              |               |
 |                |                |              |               |
 |<--REPORT (31)--|                |              |               |
 |                |                |              |               |
 |--200 OK (32)-->|                |              |               |
 |                |                |              |               |
 |                |--200 OK (33)-->|              |               |
 |                |                |              |               |
 |                |                |-200 OK (34)->|               |
 |                |                |              |               |
 |                |                |              |--200 OK (35)->|
 |                |                |              |               |
 |                |                |              |               |
]]>
</artwork></figure>
<t>
1 AUTH Alice -> r1.example.com (MSRP) - Alice wants to authenticate itself with
               the first relay </t>
<figure><artwork><![CDATA[

AUTH msrp:r1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
Expires: 3600

]]>
</artwork></figure>
<t>
2 401 Unauthorized r1.example.com -> Alice (MSRP) - Relay challenges Alice </t>
<figure><artwork><![CDATA[

MSRP/1.0 401 Unauthorized
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Expires: 3600
WWW-Authenticate: Digest
     realm="testrealm@host.com",
     qop="auth",
     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
     opaque="5ccc069c403ebaf9f0171e9517f40e41"

]]>
</artwork></figure>
<t>
3 AUTH Alice -> r1.example.com (MSRP) - Alice responds to the challenge </t>
<figure><artwork><![CDATA[

AUTH msrp:r1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
Expires: 3600
Authorization: Digest username="Alice",
     realm="testrealm@host.com",
     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
     uri="msrp:r1.example.com",
     qop=auth,
     nc=00000001,
     cnonce="0a4f113b",
     response="6629fae49393a05397450978507c4ef1",
     opaque="5ccc069c403ebaf9f0171e9517f40e41"


]]>
</artwork></figure>
<t>
4 200 OK r1.example.com -> Alice (MSRP) - Relay responds to Alice with its
                          authentication info </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK 
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Expires: 3600
Authentication-info: rspauth="msrp:saiulfywifucbscb@r1.example.com"

]]>
</artwork></figure>
<t>
5 AUTH Bob -> r3.example.com (MSRP) - Bob wants to authenticate with its
             relay </t>
<figure><artwork><![CDATA[

AUTH msrp:r3.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bK4b43c2ff8.1
Expires: 3600

]]>
</artwork></figure>
<t>
6 401 AUTH r3.example.com -> Bob (MSRP) - Relay challenges Bob </t>
<figure><artwork><![CDATA[

MSRP/1.0 401 Unauthorized
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Expires: 3600
WWW-Authenticate: Digest
     realm="testrealm@host.com",
     qop="auth",
     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
     opaque="5ccc069c403ebaf9f0171e9517f40e41"


]]>
</artwork></figure>
<t>
7 AUTH Bob -> r3.example.com (MSRP) - Bob responds to the challenge </t>
<figure><artwork><![CDATA[

AUTH msrp:r3.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bK4b43c2ff8.1
Expires: 3600
Authorization: Digest username="Bob",
     realm="testrealm@host.com",
     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
     uri="msrp:r3.example.com",
     qop=auth,
     nc=00000001,
     cnonce="0a4f113b",
     response="6629fae49393a05397450978507c4ef1",
     opaque="5ccc069c403ebaf9f0171e9517f40e41"

]]>
</artwork></figure>
<t>
8 200 OK r3.example.com -> Bob (MSRP) - Relay responds to Bob with its
                          authentication information </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK 
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Expires: 3600
Authentication-Info: rspauth="msrp:skusblfygwuhrwuh@r3.example.com"

]]>
</artwork></figure>
<t>
9 AUTH Alice -> r1.example.com (MSRP) - Alice wants to authenticate itself with
               its second relay now </t>
<figure><artwork><![CDATA[

AUTH msrp:r2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
Route:msrp:saiulfywifucbscb@r1.example.com
Expires: 3600

]]>
</artwork></figure>
<t>
10 AUTH r1.example.com -> r2.example.com (MSRP) - This authenicate request is
                         routed through the first relay, to which Alice has
                         already authenticated itself </t>
<figure><artwork><![CDATA[

AUTH msrp:r2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=sldhgsdhgqfwaf
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Expires: 3600

]]>
</artwork></figure>
<t>
11 401 AUTH r2.example.com -> r1.example.com (MSRP) - Relay 2 challenges
                             Alice </t>
<figure><artwork><![CDATA[

MSRP/1.0 401 Unauthorized
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=sldhgsdhgqfwaf
;received=192.0.2.4
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Expires: 3600
WWW-Authenticate: Digest
     realm="testrealm@host.com",
     qop="auth",
     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
     opaque="5ccc069c403ebaf9f0171e9517f40e41"


]]>
</artwork></figure>
<t>
12 401 AUTH r1.example.com -> Alice (MSRP) - Relay 1 passes on the challenge to
                             Alice </t>
<figure><artwork><![CDATA[

MSRP/1.0 401 Unauthorized
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Expires: 3600
WWW-Authenticate: Digest
     realm="testrealm@host.com",
     qop="auth",
     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
     opaque="5ccc069c403ebaf9f0171e9517f40e41"

]]>
</artwork></figure>
<t>
13 AUTH Alice -> r1.example.com (MSRP) - Alice responds to the challenge </t>
<figure><artwork><![CDATA[

AUTH msrp:r2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
Route: msrp:saiulfywifucbscb@r1.example.com
Expires: 3600
Authorization: Digest username="Alice",
     realm="testrealm@host.com",
     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
     uri="msrp:r2.example.com",
     qop=auth,
     nc=00000001,
     cnonce="0a4f113b",
     response="6629fae49393a05397450978507c4ef1",
     opaque="5ccc069c403ebaf9f0171e9517f40e41"

]]>
</artwork></figure>
<t>
14 AUTH r1.example.com -> r2.example.com (MSRP) - Relay 1 passes on Alice's
                         response to Relay 2 </t>
<figure><artwork><![CDATA[

AUTH msrp:r2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=sldhgsdhgqfwaf
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Expires: 3600
Authorization: Digest username="Alice",
     realm="testrealm@host.com",
     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
     uri="msrp:r2.example.com",
     qop=auth,
     nc=00000001,
     cnonce="0a4f113b",
     response="6629fae49393a05397450978507c4ef1",
     opaque="5ccc069c403ebaf9f0171e9517f40e41"

]]>
</artwork></figure>
<t>
15 200 OK r2.example.com -> r1.example.com (MSRP) - Relay 2 accepts Alice's
                           response and sends back its authentication info </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK 
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=sldhgsdhgqfwaf
 ;received=192.0.2.4
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Expires: 3600
Authentication-Info: rspauth="msrp:eioweoerhgerofef@r2.example.com"


]]>
</artwork></figure>
<t>
16 200 OK r1.example.com -> Alice (MSRP) - Relay 1 forwards Relay2's
                           authentication info to Alice </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK 
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Expires: 3600
Authentication-Info: rspauth="msrp:eioweoerhgerofef@r2.example.com"

]]>
</artwork></figure>
<t>
17 INVITE Alice -> Bob (SIP) : Alice sends an INVITe to Bob to start an IM
                  session, with an SDP offer for the session. </t>
<figure><artwork><![CDATA[

INVITE sip:bob@pc1.example.com SIP/2.0
Via: SIP/2.0/UDP pc2.atlanta.com;branch=z9hG4bKkjshdyff
To: Bob <sip:bob@pc1.example.com>
From: Alice <sip:alice@pc2.example.com>;tag=88sja8x
Max-Forwards: 70
Call-ID: 987asjd97y7atg
CSeq: 986759 INVITE
Content-Type: application/ sdp
Content-Length: 120

c=IN IP4 invalid.none
m=message 1234 sims/tcp+tls alice@pc2.example.com
a=accept-types:text/plain message/cpim
a=hop:msrp:saiulfywifucbscb@r1.example.com
a=hop:msrp:eioweoerhgerofef@r2.example.com

]]>
</artwork></figure>
<t>
18 200 OK Bob -> Alice (SIP): Bob responds with a 200 OK and an answer SDP. </t>
<figure><artwork><![CDATA[

SIP/2.0 200 OK
Via: SIP/2.0/UDP pc2.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
To: Bob <sip:bob@pc1.example.com>;tag=a6c85cf
From: Alice <sip:alice@pc2.example.com>;tag=88sja8x
Call-ID: 987asjd97y7atg
CSeq: 986759 INVITE
Content-Type: application/sdp
Content-Length: 131

c=IN IP4 invalid.none
m=message 1234 sims/tcp+tls bob@pc1.example.com
a=accept-types:text/plain 
a=hop:msrp:skusblfygwuhrwuh@r3.example.com

]]>
</artwork></figure>
<t>
19 ACK Alice -> Bob (SIP): Alice sends an ACK to Bob and the session is
               successfully set up. Alice and Bob can now start sending messages
               to each other. </t>
<figure><artwork><![CDATA[

ACK sip:bob@pc1.example.com SIP/2.0
Via: SIP/2.0/UDP pc2.example.com;branch=z9hG4bKkjshdyff
To: Bob <sip:bob@pc1.example.com>;tag=a6c85cf
From: Alice <sip:alice@pc2.example.com>;tag=88sja8x
Max-Forwards: 70
Call-ID: 987asjd97y7atg
CSeq: 986759 ACK

]]>
</artwork></figure>
<t>
20 SEND Alice -> r1.example.com (MSRP) - Alice sends a SEND to Bob. This will
                 be routed through the three relays </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bKkjshdyff
Route: msrp:saiulfywifucbscb@r1.example.com
Route: msrp:eioweoerhgerofef@r2.example.com
Route: msrp:skusblfygwuhrwuh@r3.example.com
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type:  text/plain;boundary=-----bound123456

-------bound123456
Hi Bob! How are you?
-------bound123456

]]>
</artwork></figure>
<t>
21 200 OK r1.example.com -> Alice (MSRP) - Relay 1 responds to Alice that the
                           SEND has reached it successfully. </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=z9hG4bKkjshdyff
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
22 SEND r1.example.com -> r2.example.com (MSRP) - Relay 1 forwards the SEND
                          as-is to Relay2 </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=sldhgsdhgqfwaf
Route: msrp:eioweoerhgerofef@r2.example.com
Route: msrp:skusblfygwuhrwuh@r3.example.com
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type:  text/plain;boundary=-----bound123456

-------bound123456
Hi Bob! How are you?
-------bound123456

]]>
</artwork></figure>
<t>
23 200 OK r2.example.com -> r1.example.com (MSRP) - Relay2 responds to Relay1
                           that the SEND has reached it successfully </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=sldhgsdhgqfwaf
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
24 SEND r2.example.com -> r3.example.com (MSRP) - Relay2 forwards the SEND
                          as-is to Relay3 </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r2.example.com;branch=wuoshfuetyheiot
Route: msrp:skusblfygwuhrwuh@r3.example.com
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type:  text/plain;boundary=-----bound123456

-------bound123456
Hi Bob! How are you?
-------bound123456

]]>
</artwork></figure>
<t>
25 200 OK r3.example.com -> r2.example.com (MSRP) - Relay3 responds to Relay2
                           that the SEND has reached it successfully </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r2.example.com;branch=wuoshfuetyheiot
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
26 SEND r3.example.com -> Bob (MSRP) - Relay3 forwards the SEND to Bob </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r3.example.com;branch=hsruoghlweugho
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type: text/plain;boundary=-----bound123456

-------bound123456
Hi Bob! How are you?
-------bound123456

]]>
</artwork></figure>
<t>
27 200 OK Bob -> r3.example.com (MSRP) - Bob reports its successful delivery tp
                relay3 </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r3.example.com;branch=hsruoghlweugho
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
28 REPORT Bob -> r3.example.com (MSRP) - Bob now sends an REPORT to Alice to
                indicate the successful end-to-end delivery of the message </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
Route: msrp:skusblfygwuhrwuh@r3.example.com
Route: msrp:eioweoerhgerofef@r2.example.com
Route: msrp:saiulfywifucbscb@r1.example.com
Delivery-Status:ok
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
29 REPORT r3.example.com -> r2.example.com (MSRP) </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r3.example.com;branch=wvehrugheurghei
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Route: msrp:eioweoerhgerofef@r2.example.com
Route: msrp:saiulfywifucbscb@r1.example.com
Delivery-Status:ok
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
30 REPORT r2.example.com -> r1.example.com (MSRP) </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r2.example.com;brnach=woifwehfovndjnv
Via: MSRP/1.0/TCP-TLS r3.example.com;branch=wvehrugheurghei
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Route: msrp:saiulfywifucbscb@r1.example.com
Delivery-Status:ok
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
31 REPORT r1.example.com -> Alice (MSRP) </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=wkehweiothoqowq
Via: MSRP/1.0/TCP-TLS r2.example.com;brnach=woifwehfovndjnv
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS r3.example.com;branch=wvehrugheurghei
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Delivery-Status:ok
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
32 200 OK Alice -> r1.example.com (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=wkehweiothoqowq
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS r2.example.com;brnach=woifwehfovndjnv
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS r3.example.com;branch=wvehrugheurghei
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
33 200 OK r1.example.com -> r2.example.com (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r2.example.com;brnach=woifwehfovndjnv
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS r3.example.com;branch=wvehrugheurghei
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
34 200 OK r2.example.com -> r3.example.com (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r3.example.com;branch=wvehrugheurghei
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
35 200 OK r3.example.com -> Bob (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg
]]>
</artwork></figure>
</section>
<section title="client fragmentation">
<t>
In this example, Alice wants to send a message to Bob. Alice decides to fragment this message into two parts.
</t>
<figure><artwork><![CDATA[
        Alice              r.example.com                Bob
          |                       |                      |
          |----SEND (1)--------->|                      |
          |                       |                      |
          |<-----200 OK (2)-------|                      |
          |                       |                      |
          |                       |-------SEND (3)----->|
          |                       |                      |
          |                       |<------200 OK (4)-----|
          |                       |                      |
          |                       |<-----REPORT (5)------|
          |                       |                      |
          |<-------REPORT (6)-----|                      |
          |                       |                      |
          |------200 OK (7)------>|                      |
          |                       |                      |
          |                       |------200 OK (8)----->|
          |                       |                      |
          |------SEND (9)------->|                      |
          |                       |                      |
          |<-------200 OK (10)----|                      |
          |                       |                      |
          |                       |-----SEND (11)------>|
          |                       |                      |
          |                       |<-----200 OK (12)-----|
          |                       |                      |
          |                       |<------REPORT (13)----|
          |                       |                      |
          |<-----REPORT (14)------|                      |
          |                       |                      |
          |------200 OK (15)----->|                      |
          |                       |                      |
          |                       |-----200 OK (16)----->|
          |                       |                      |


]]>
</artwork></figure>
<t>
1 SEND Alice -> r1.example.com (MSRP) - Alice sends the first SEND </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=hsruoghlweugho
Route: saiulfywifucbscb@r1.example.com
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type: multipart/byteranges; boundary=-----bound123456

-------bound123456
Content-type: text/plain
Content-range: bytes 0-44/96

This is the first part of a two-part message
-------bound123456

]]>
</artwork></figure>
<t>
2 200 OK r1.example.com -> Alice (MSRP) - Relay1 receives the SEND
                          successfully </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=hsruoghlweugho
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
3 SEND r1.example.com -> Bob (MSRP) - Relay forwards the SEND as-is to
                         Bob </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=shoghwogiwhgokb
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type: multipart/byteranges; boundary=-----bound123456

-------bound123456
Content-type: text/plain
Content-range: bytes 0-44/96

This is the first part of a two-part message
-------bound123456

]]>
</artwork></figure>
<t>
4 200 OK Bob -> r1.example.com (MSRP) - SEND reaches Bob successfully </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=shoghwogiwhgokb
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
5 REPORT Bob -> r1.example.com (MSRP) - Bob REPORTs Alice about the successful
               end-to-end delivery of the first part of the message </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
Route: msrp:saiulfywifucbscb@r1.example.com
Delivery-Status:ok;range=0-44
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
6 REPORT r1.example.com -> Alice (MSRP) - REPORT gets forwarded by the
                          relay </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=wuwfiuhwifuhwif
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Delivery-Status:ok;range=0-44
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
7 200 OK Alice -> r1.example.com (MSRP) - Alice responds to the REPORT </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=wuwfiuhwifuhwif
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
8 200 OK r1.example.com -> Bob (MSRP) - Relay forwards the response to the
                          REPORT to Bob </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
9 SEND Alice -> r1.example.com (MSRP) - Alice sends the second SEND of the
                message to Bob </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=hsruoghlweugho
Route: saiulfywifucbscb@r1.example.com
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type: multipart/byteranges; boundary=-----bound123456

-------bound123456
Content-type: text/plain
Content-range: bytes 45-96/96

This is the second and the last part of this message
-------bound123456

]]>
</artwork></figure>
<t>
10 200 OK r1.example.com -> Alice (MSRP)  </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=hsruoghlweugho
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
11 SEND r1.example.com -> Bob (MSRP) - Relay passes on the second SEND as-is
                          to Bob </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=shoghwogiwhgokb
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type: multipart/byteranges; boundary=-----bound123456

-------bound123456
Content-type: text/plain
Content-range: bytes 45-96/96

This is the second and the last part of this message
-------bound123456

]]>
</artwork></figure>
<t>
12 200 OK Bob -> r1.example.com (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=shoghwogiwhgokb
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
13 REPORT Bob -> r1.example.com (MSRP) - Bob REPORTs Alice of the successful
                end-to-end delivery of the entire message </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
Route: msrp:saiulfywifucbscb@r1.example.com
Delivery-Status:ok
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
14 REPORT r1.example.com -> Alice (MSRP) </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=wuwfiuhwifuhwif
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Delivery-Status:ok
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
15 200 OK Alice -> r1.example.com (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=wuwfiuhwifuhwif
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
16 200 OK r1.example.com -> Bob (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg
]]>
</artwork></figure>
</section>
<section title="relay fragmentation">
<t>
In this example, Alice sends a message to Bob in a single SEND request. The relay decides that it needs to fragment the message into two parts.
</t>
<figure><artwork><![CDATA[
        Alice               r.example.com               Bob
          |                       |                      |
          |-------SEND (1)------>|                      |
          |                       |                      |
          |<-----200 OK (2)-------|                      |
          |                       |                      |
          |                       |-------SEND (3)----->|
          |                       |                      |
          |                       |<------200 OK (4)-----|
          |                       |                      |
          |                       |<------REPORT (5)-----|
          |                       |                      |
          |<-------REPORT (6)-----|                      |
          |                       |                      |
          |--------200 OK (7)---->|                      |
          |                       |                      |
          |                       |------200 OK (8)----->|
          |                       |                      |
          |                       |------SEND (9)------>|
          |                       |                      |
          |                       |<-----200 OK (10)-----|
          |                       |                      |
          |                       |<-----REPORT (11)-----|
          |                       |                      |
          |<------REPORT (12)-----|                      |
          |                       |                      |
          |-------200 OK (13)---->|                      |
          |                       |                      |
          |                       |-------200 OK (14)--->|
          |                       |                      |
          

]]>
</artwork></figure>
<t>
1 SEND Alice -> r1.example.com (MSRP) - Alice sends a message to Bob. </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=hsruoghlweugho
Route: saiulfywifucbscb@r1.example.com
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type: text/plain;boundary=-----bound123456

-------bound123456
This is the entire message which will be split into two by the relay
-------bound123456

]]>
</artwork></figure>
<t>
2 200 OK r1.example.com -> Alice (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc2.example.com;branch=hsruoghlweugho
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
3 SEND r1.example.com -> Bob (MSRP) - Relay1 splits up the message body in the
                         SEND message, and sends the first part to Bob. </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=scjbsdjfksbfsdj
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type: multipart/byteranges; boundary=-----bound123456

-------bound123456
Content-type: text/plain
Content-range: bytes 0-32/68

This is the entire message which 
-------bound123456

]]>
</artwork></figure>
<t>
4 200 OK Bob -> r1.example.com (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=scjbsdjfksbfsdj
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
5 REPORT Bob -> r1.example.com (MSRP) - Bob REPORTs Alice of the successful
               end-to-end delivery of the first 32 bytes of the message </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
Route: msrp:saiulfywifucbscb@r1.example.com
Delivery-Status:ok;range=0-32
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
6 REPORT r1.example.com -> Alice (MSRP)  </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=wsuefhwejhfwejfh
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Delivery-Status:ok;range=0-32
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
7 200 OK Alice -> r1.example.com (MSRP) - Alice waits for the REPORT for the
                 remaining bytes that it has already sent </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=wsuefhwejhfwejfh
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
8 200 OK r1.example.com -> Bob (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
9 SEND r1.example.com -> Bob (MSRP) - Relay1 now sends the remaining message in
                         a second SEND message to Bob </t>
<figure><artwork><![CDATA[

SEND msrp:bob@pc1.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=scjbsdjfksbfsdj
Call-ID: 987asjd97y7atg
Message-ID: 34561345
Max-Forwards: 70
Content-Type: multipart/byteranges; boundary=-----bound123456

-------bound123456
Content-type: text/plain
Content-range: bytes 33-68/68

 will be split into two by the relay
-------bound123456

]]>
</artwork></figure>
<t>
10 200 OK Bob -> r1.example.com (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=scjbsdjfksbfsdj
 ;received=192.0.2.3
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
11 REPORT Bob -> r1.example.com (MSRP) - Bob REPORTs Alice about the successful
                end-to-end delivery of the entire message </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
Route: msrp:saiulfywifucbscb@r1.example.com
Delivery-Status:ok
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
12 REPORT r1.example.com -> Alice (MSRP) </t>
<figure><artwork><![CDATA[

REPORT msrp:alice@pc2.example.com MSRP/1.0
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=wsuefhwejhfwejfh
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Delivery-Status:ok
Message-ID: 34561345
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
13 200 OK Alice -> r1.example.com (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS r1.example.com;branch=wsuefhwejhfwejfh
 ;received=192.0.2.3
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg

]]>
</artwork></figure>
<t>
14 200 OK r1.example.com -> Bob (MSRP) </t>
<figure><artwork><![CDATA[

MSRP/1.0 200 OK
Via: MSRP/1.0/TCP-TLS pc1.example.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Call-ID: 987asjd97y7atg
]]>
</artwork></figure>
</section>
</section>
-->
     
<section title="Acknowledgments">
<t>
Many thanks to the following members of the SIMPLE WG for spirited discussions on session mode:  Ben Campbell, Jonathan Rosenberg, Robert Sparks, Paul Kyzivat, Allison Mankin, Jon Peterson,  Brian Rosen, Dean Willis, Adam Roach, Aki Niemi, Hisham Khartabil, Pekka Pessi, and Chris Boulton 
</t>
</section>

  </middle>

  <back>
    <references title="Normative References">



<reference anchor='RFC2617'>

<front>
<title abbrev='HTTP Authentication'>HTTP Authentication: Basic and Digest Access Authentication</title>
<author initials='J.' surname='Franks' fullname='John Franks'>
<organization>Northwestern University, Department of Mathematics</organization>
<address>
<postal>
<street />
<city>Evanston</city>
<region>IL</region>
<code>60208-2730</code>
<country>US</country></postal>
<email>john@math.nwu.edu</email></address></author>
<author initials='P.M.' surname='Hallam-Baker' fullname='Phillip M. Hallam-Baker'>
<organization>Verisign Inc.</organization>
<address>
<postal>
<street>301 Edgewater Place</street>
<street>Suite 210</street>
<city>Wakefield</city>
<region>MA</region>
<code>01880</code>
<country>US</country></postal>
<email>pbaker@verisign.com</email></address></author>
<author initials='J.L.' surname='Hostetler' fullname='Jeffery L. Hostetler'>
<organization>AbiSource, Inc.</organization>
<address>
<postal>
<street>6 Dunlap Court</street>
<city>Savoy</city>
<region>IL</region>
<code>61874</code>
<country>US</country></postal>
<email>jeff@AbiSource.com</email></address></author>
<author initials='S.D.' surname='Lawrence' fullname='Scott D. Lawrence'>
<organization>Agranat Systems, Inc.</organization>
<address>
<postal>
<street>5 Clocktower Place</street>
<street>Suite 400</street>
<city>Maynard</city>
<region>MA</region>
<code>01754</code>
<country>US</country></postal>
<email>lawrence@agranat.com</email></address></author>
<author initials='P.J.' surname='Leach' fullname='Paul J. Leach'>
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials='A.' surname='Luotonen' fullname='Ari Luotonen'>
<organization>Netscape Communications Corporation</organization>
<address>
<postal>
<street>501 East Middlefield Road</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country></postal></address></author>
<author initials='L.' surname='Stewart' fullname='Lawrence C. Stewart'>
<organization>Open Market, Inc.</organization>
<address>
<postal>
<street>215 First Street</street>
<city>Cambridge</city>
<region>MA</region>
<code>02142</code>
<country>US</country></postal>
<email>stewart@OpenMarket.com</email></address></author>
<date month='June' year='1999' />
<abstract>
<t>"HTTP/1.0", includes the specification for a Basic Access  Authentication scheme. This scheme is not considered to be a secure method of user authentication (unless used in conjunction with some external secure system such as SSL, as the user name and password are passed over the network as cleartext.</t>
<t>This document also provides the specification for HTTP's authentication framework, the original Basic authentication scheme and a scheme based on cryptographic hashes, referred to as "Digest Access Authentication".  It is therefore also intended to serve as a replacemen for RFC 2069.  Some optional elements specified by  RFC 2069 have been removed from this specification due to problems found since its publication; other new elements have been added for
   compatibility, those new elements have been made optional, but are strongly recommended.</t>
<t>Like Basic, Digest access authentication verifies that both parties to a communication know a shared secret (a password); unlike Basic,  this verification can be done without sending the password in the clear, which is Basic's biggest weakness. As with most other authentication protocols, the greatest sources of risks are usually  found not in the core protocol itself but in policies and procedures surrounding its use.</t></abstract></front>

<seriesInfo name='RFC' value='2617' />
</reference>



<reference anchor='RFC2246'>

<front>
<title>The TLS Protocol Version 1.0</title>
<author initials='T.' surname='Dierks' fullname='Tim Dierks'>
<organization>Certicom</organization>
<address>
<email>tdierks@certicom.com</email></address></author>
<author initials='C.' surname='Allen' fullname='Christopher Allen'>
<organization>Certicom</organization>
<address>
<email>callen@certicom.com</email></address></author>
<author initials='W.' surname='Treese' fullname='Win Treese'>
<organization>Open Market</organization>
<address>
<email>treese@openmarket.com</email></address></author>
<author initials='P.L.' surname='Karlton' fullname='Philip L. Karlton'>
<organization>Netscape Communications</organization>
<address></address></author>
<author initials='A.O.' surname='Freier' fullname='Alan O. Freier'>
<organization>Netscape Communications</organization>
<address>
<email>freier@netscape.com</email></address></author>
<author initials='P.C.' surname='Kocher' fullname='Paul C. Kocher'>
<organization>Independent Consultant</organization>
<address>
<email>pck@netcom.com</email></address></author>
<date month='January' year='1999' />
<abstract>
<t>This document specifies Version 1.0 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications privacy over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.</t></abstract></front>

<seriesInfo name='RFC' value='2246' />
</reference>



<reference anchor='RFC2045'>

<front>
<title abbrev='Internet Message Bodies'>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
<author initials='N.' surname='Freed' fullname='Ned Freed'>
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 East Garvey Avenue South</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country></postal>
<phone>+1 818 919 3600</phone>
<facsimile>+1 818 919 3614</facsimile>
<email>ned@innosoft.com</email></address></author>
<author initials='N.S.' surname='Borenstein' fullname='Nathaniel S. Borenstein'>
<organization>First Virtual Holdings</organization>
<address>
<postal>
<street>25 Washington Avenue</street>
<city>Morristown</city>
<region>NJ</region>
<code>07960</code>
<country>US</country></postal>
<phone>+1 201 540 8967</phone>
<facsimile>+1 201 993 3032</facsimile>
<email>nsb@nsb.fv.com</email></address></author>
<date month='November' year='1996' />
<abstract>
<t>STD 11, RFC 822, defines a message representation protocol specifying considerable detail about US-ASCII message headers, and leaves the message content, or message body, as flat US-ASCII text.  This set of documents, collectively called the Multipurpose Internet Mail Extensions, or MIME, redefines the format of messages to allow for</t>
<t>(1)   textual message bodies in character sets other than US-ASCII,</t>
<t>(2)   an extensible set of different formats for non-textual message bodies,</t>
<t>(3)   multi-part message bodies, and</t>
<t>(4)   textual header information in character sets other than US-ASCII.</t>
<t>These documents are based on earlier work documented in RFC 934, STD 11, and RFC 1049, but extends and revises them.  Because RFC 822 said so little about message bodies, these documents are largely orthogonal to (rather than a revision of) RFC 822.</t>
<t>This initial document specifies the various headers used to describe the structure of MIME messages. The second document, RFC 2046, defines the general structure of the MIME media typing system and defines an initial set of media types. The third document, RFC 2047, describes extensions to RFC 822 to allow non-US-ASCII text data in Internet mail header fields. The fourth document, RFC 2048, specifies various IANA registration procedures for MIME-related facilities. The fifth and final document, RFC 2049, describes MIME conformance
  criteria as well as providing some illustrative examples of MIME message formats, acknowledgements, and the bibliography.</t>
<t>These documents are revisions of RFCs 1521, 1522, and 1590, which themselves were revisions of RFCs 1341 and 1342.  An appendix in RFC 2049 describes differences and changes from previous versions.</t></abstract></front>

<seriesInfo name='RFC' value='2045' />
</reference>



<reference anchor='RFC2046'>

<front>
<title abbrev='Media Types'>Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</title>
<author initials='N.' surname='Freed' fullname='Ned Freed'>
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 East Garvey Avenue South</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country></postal>
<phone>+1 818 919 3600</phone>
<facsimile>+1 818 919 3614</facsimile>
<email>ned@innosoft.com</email></address></author>
<author initials='N.' surname='Borenstein' fullname='Nathaniel S. Borenstein'>
<organization>First Virtual Holdings</organization>
<address>
<postal>
<street>25 Washington Avenue</street>
<city>Morristown</city>
<region>NJ</region>
<code>07960</code>
<country>US</country></postal>
<phone>+1 201 540 8967</phone>
<facsimile>+1 201 993 3032</facsimile>
<email>nsb@nsb.fv.com</email></address></author>
<date month='November' year='1996' />
<abstract>
<t>STD 11, RFC 822 defines a message representation protocol specifying considerable detail about US-ASCII message headers, but which leaves the message content, or message body, as flat US-ASCII text.  This set of documents, collectively called the Multipurpose Internet Mail Extensions, or MIME, redefines the format of messages to allow for</t>
<t>(1)   textual message bodies in character sets other than US-ASCII,</t>
<t>(2)   an extensible set of different formats for non-textual message bodies,</t>
<t>(3)   multi-part message bodies, and</t>
<t>(4)   textual header information in character sets other than US-ASCII.</t>
<t>These documents are based on earlier work documented in RFC 934, STD 11 and RFC 1049, but extends and revises them.  Because RFC 822 said so little about message bodies, these documents are largely orthogonal to (rather than a revision of) RFC 822.</t>
<t>The initial document in this set, RFC 2045, specifies the various headers used to describe the structure of MIME messages. This second document defines the general structure of the MIME media typing sytem and defines an initial set of media types. The third document, RFC 2047, describes extensions to RFC 822 to allow non-US-ASCII text data in Internet mail header fields. The fourth document, RFC 2048, specifies various IANA registration procedures for MIME-related facilities.  The fifth and final document, RFC 2049, describes MIME
   conformance criteria as well as providing some illustrative examples of MIME message formats, acknowledgements, and the bibliography.</t>
<t>These documents are revisions of RFCs 1521 and 1522, which themselves were revisions of RFCs 1341 and 1342.  An appendix in RFC 2049 describes differences and changes from previous versions.</t></abstract></front>

<seriesInfo name='RFC' value='2046' />
</reference>



<reference anchor='RFC2633'>

<front>
<title>S/MIME Version 3 Message Specification</title>
<author initials='B.' surname='Ramsdell' fullname='Blake Ramsdell'>
<organization>Worldtalk</organization>
<address>
<postal>
<street>17720 NE 65th Street</street>
<street>Suite 201</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<phone>+1 425 376 0225</phone>
<email>blaker@deming.com</email></address></author>
<date month='June' year='1999' /></front>

<seriesInfo name='RFC' value='2633' />
</reference>



<reference anchor='RFC2396'>

<front>
<title abbrev='URI Generic Syntax'>Uniform Resource Identifiers (URI): Generic Syntax</title>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='MIT/LCS'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<author initials='R.T.' surname='Fielding' fullname='Roy T. Fielding'>
<organization abbrev='U.C. Irvine'>Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Xerox Corporation'>Xerox PARC</organization>
<address>
<postal>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<facsimile>+1(415)812-4333</facsimile>
<email>masinter@parc.xerox.com</email></address></author>
<date month='August' year='1998' />
<area>Applications</area>
<keyword>uniform resource</keyword>
<keyword>URI</keyword>
<abstract>
<t>
   A Uniform Resource Identifier (URI) is a compact string of characters
   for identifying an abstract or physical resource.  This document
   defines the generic syntax of URI, including both absolute and
   relative forms, and guidelines for their use; it revises and replaces
   the generic definitions in RFC 1738 and RFC 1808.
</t>
<t>
   This document defines a grammar that is a superset of all valid URI,
   such that an implementation can parse the common components of a URI
   reference without knowing the scheme-specific requirements of every
   possible identifier type.  This document does not define a generative
   grammar for URI; that task will be performed by the individual
   specifications of each URI scheme.
</t></abstract>
<note title='IESG Note'>
<t>
   This paper describes a "superset" of operations that can be applied
   to URI.  It consists of both a grammar and a description of basic
   functionality for URI.  To understand what is a valid URI, both the
   grammar and the associated description have to be studied.  Some of
   the functionality described is not applicable to all URI schemes, and
   some operations are only possible when certain media types are
   retrieved using the URI, regardless of the scheme used.
</t></note></front>

<seriesInfo name='RFC' value='2396' />
<format type='HTML' octets='114242' target='http://xml.resource.org/public/rfc/html/rfc2396.html' />
<format type='XML' octets='95582' target='http://xml.resource.org/public/rfc/xml/rfc2396.xml' />
</reference>



<reference anchor='RFC2782'>

<front>
<title abbrev='DNS SRV RR'>A DNS RR for specifying the location of services (DNS SRV)</title>
<author initials='A.' surname='Gulbrandsen' fullname='Arnt Gulbrandsen'>
<organization>Troll Tech</organization>
<address>
<postal>
<street>Waldemar Thranes gate 98B</street>
<city>Oslo</city>
<region />
<code>N-0175</code>
<country>NO</country></postal>
<phone>+47 22 806390</phone>
<facsimile>+47 22 806380</facsimile>
<email>arnt@troll.no</email></address></author>
<author initials='P.' surname='Vixie' fullname='Paul Vixie'>
<organization>Internet Software Consortium</organization>
<address>
<postal>
<street>950 Charter Street</street>
<city>Redwood City</city>
<region>CA</region>
<code>94063</code>
<country>US</country></postal>
<phone>+1 650 779 7001</phone></address></author>
<author initials='L.' surname='Esibov' fullname='Levon Esibov'>
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>One Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<email>levone@microsoft.com</email></address></author>
<date month='February' year='2000' />
<abstract>
<t>This document describes a DNS RR which specifies the location of the
   server(s) for a specific protocol and domain.</t></abstract></front>

<seriesInfo name='RFC' value='2782' />
</reference>



<reference anchor='RFC3546'>

<front>
<title>Transport Layer Security (TLS) Extensions</title>
<author initials='S.' surname='Blake-Wilson' fullname='S. Blake-Wilson'>
<organization /></author>
<author initials='M.' surname='Nystrom' fullname='M. Nystrom'>
<organization /></author>
<author initials='D.' surname='Hopwood' fullname='D. Hopwood'>
<organization /></author>
<author initials='J.' surname='Mikkelsen' fullname='J. Mikkelsen'>
<organization /></author>
<author initials='T.' surname='Wright' fullname='T. Wright'>
<organization /></author>
<date month='June' year='2003' /></front>

<seriesInfo name='RFC' value='3546' />
</reference>



<reference anchor='RFC3268'>

<front>
<title>Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)</title>
<author initials='P.' surname='Chown' fullname='P. Chown'>
<organization /></author>
<date month='June' year='2002' /></front>

<seriesInfo name='RFC' value='3268' />
</reference>



<reference anchor='RFC1123'>

<front>
<title>Requirements for Internet Hosts - Application and Support</title>
<author initials='R.' surname='Braden' fullname='Robert Braden'>
<organization>University of Southern California (USC), Information Sciences Institute</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90292-6695</code>
<country>US</country></postal>
<phone>+1 213 822 1511</phone>
<email>Braden@ISI.EDU</email></address></author>
<date month='October' year='1989' /></front>

<seriesInfo name='STD' value='3' />
<seriesInfo name='RFC' value='1123' />
</reference>



<reference anchor='RFC2183'>

<front>
<title abbrev='Content-Disposition'>Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field</title>
<author initials='R.' surname='Troost' fullname='Rens Troost'>
<organization>New Century Systems</organization>
<address>
<postal>
<street>324 East 41st Street #804</street>
<street>New York</street>
<street>NY</street>
<street>10017</street>
<country>USA</country></postal>
<phone>+1 (212) 557-2050</phone>
<facsimile>+1 (212) 557-2049</facsimile>
<email>rens@century.com</email></address></author>
<author initials='S.' surname='Dorner' fullname='Steve Dorner'>
<organization>QUALCOMM Incorporated</organization>
<address>
<postal>
<street>6455 Lusk Boulevard</street>
<street>San Diego</street>
<street>CA 92121</street>
<country>USA</country></postal>
<email>sdorner@qualcomm.com</email></address></author>
<author initials='K.' surname='Moore' fullname='Keith Moore'>
<organization>Department of Computer Science</organization>
<address>
<postal>
<street>University of Tennessee</street>
<street>Knoxville</street>
<street>107 Ayres Hall</street>
<street>Knoxville TN  37996-1301</street>
<country>USA</country></postal>
<phone>+1 (423) 974-5067</phone>
<facsimile>+1 (423) 974-8296</facsimile>
<email>moore@cs.utk.edu</email></address></author>
<date month='August' year='1997' />
<area>Applications</area>
<keyword>MIME</keyword>
<keyword>internet message</keyword>
<keyword>multipurpose internet mail extensions</keyword>
<abstract>
<t>
   This memo provides a mechanism whereby messages conforming to the
   MIME specifications [RFC 2045, RFC 2046, RFC 2047, RFC 2048, RFC
   2049] can convey presentational information.  It specifies the
   &quot;Content-Disposition&quot; header field, which is optional and valid for
   any MIME entity (&quot;message&quot; or &quot;body part&quot;).  Two values for this
   header field are described in this memo; one for the ordinary linear
   presentation of the body part, and another to facilitate the use of
   mail to transfer files.  It is expected that more values will be
   defined in the future, and procedures are defined for extending this
    set of values.
</t>
<t>
   This document is intended as an extension to MIME.  As such, the
   reader is assumed to be familiar with the MIME specifications, and
   [RFC 822].  The information presented herein supplements but does not
   replace that found in those documents.
</t>
<t>
   This document is a revision to the Experimental protocol defined in
   RFC 1806.  As compared to RFC 1806, this document contains minor
   editorial updates, adds new parameters needed to support the File
   Transfer Body Part, and references a separate specification for the
   handling of non-ASCII and/or very long parameter values.
</t></abstract></front>

<seriesInfo name='RFC' value='2183' />
<format type='HTML' octets='38526' target='http://xml.resource.org/public/rfc/html/rfc2183.html' />
<format type='XML' octets='24153' target='http://xml.resource.org/public/rfc/xml/rfc2183.xml' />
</reference>



<reference anchor='RFC2327'>

<front>
<title abbrev='SDP'>SDP: Session Description Protocol</title>
<author initials='M.' surname='Handley' fullname='Mark Handley'>
<organization>
   Information Sciences Institute
</organization>
<address>
<postal>
<street>
   c/o MIT Laboratory for Computer Science
</street>
<street>
   545 Technology Square
</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>US</country></postal>
<email>mjh@isi.edu</email></address></author>
<author initials='V.' surname='Jacobson' fullname='Van Jacobson'>
<organization>
   Lawrence Berkeley Laboratory
</organization>
<address>
<postal>
<street>
   MS 46a-1121
</street>
<city>Berkeley</city>
<region>CA</region>
<code>94720</code>
<country>US</country></postal>
<email>van@ee.lbl.gov</email></address></author>
<date month='April' year='1998' />
<area>Applications</area>
<keyword>multimedia</keyword>
<keyword>SDP</keyword>
<abstract>
<t>

   This document defines the Session Description Protocol, SDP.  SDP is

   intended for describing multimedia sessions for the purposes of

   session announcement, session invitation, and other forms of

   multimedia session initiation.
</t>
<t>


   This document is a product of the Multiparty Multimedia Session

   Control (MMUSIC) working group of the Internet Engineering Task

   Force. Comments are solicited and should be addressed to the working

   group's mailing list at confctrl@isi.edu and/or the authors.
</t></abstract></front>

<seriesInfo name='RFC' value='2327' />
<format type='HTML' octets='105361' target='http://xml.resource.org/public/rfc/html/rfc2327.html' />
<format type='XML' octets='96873' target='http://xml.resource.org/public/rfc/xml/rfc2327.xml' />
</reference>



<reference anchor='RFC3264'>

<front>
<title>An Offer/Answer Model with Session Description Protocol (SDP)</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<date month='June' year='2002' /></front>

<seriesInfo name='RFC' value='3264' />
</reference>



<reference anchor='RFC3458'>

<front>
<title>Message Context for Internet Mail</title>
<author initials='E.' surname='Burger' fullname='E. Burger'>
<organization /></author>
<author initials='E.' surname='Candell' fullname='E. Candell'>
<organization /></author>
<author initials='C.' surname='Eliot' fullname='C. Eliot'>
<organization /></author>
<author initials='G.' surname='Klyne' fullname='G. Klyne'>
<organization /></author>
<date month='January' year='2003' /></front>

<seriesInfo name='RFC' value='3458' />
</reference>

<reference anchor='RFC3261'>

<front>
<title>SIP: Session Initiation Protocol</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<author initials='G.' surname='Camarillo' fullname='G. Camarillo'>
<organization /></author>
<author initials='A.' surname='Johnston' fullname='A. Johnston'>
<organization /></author>
<author initials='J.' surname='Peterson' fullname='J. Peterson'>
<organization /></author>
<author initials='R.' surname='Sparks' fullname='R. Sparks'>
<organization /></author>
<author initials='M.' surname='Handley' fullname='M. Handley'>
<organization /></author>
<author initials='E.' surname='Schooler' fullname='E. Schooler'>
<organization /></author>
<date month='June' year='2002' /></front>

<seriesInfo name='RFC' value='3261' />
</reference>



<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date month='March' year='1997' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;,
      &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD
      NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and
      &quot;OPTIONAL&quot; in this document are to be interpreted as described
      in RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='HTML' octets='14486' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5661' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>




<reference anchor='RFC2616'>

<front>
<title abbrev='HTTP/1.1'>Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
<organization abbrev='UC Irvine'>Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='J.' surname='Gettys' fullname='James Gettys'>
<organization abbrev='Compaq/W3C'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials='J.' surname='Mogul' fullname='Jeffrey C. Mogul'>
<organization abbrev='Compaq'>Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials='H.' surname='Frystyk' fullname='Henrik Frystyk Nielsen'>
<organization abbrev='MIT/LCS'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Xerox'>Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials='P.' surname='Leach' fullname='Paul J. Leach'>
<organization abbrev='Microsoft'>Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='MIT/LCS'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date month='June' year='1999' />
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers . A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>

<seriesInfo name='RFC' value='2616' />
<format type='HTML' octets='498891' target='http://xml.resource.org/public/rfc/html/rfc2616.html' />
<format type='XML' octets='471630' target='http://xml.resource.org/public/rfc/xml/rfc2616.xml' />
</reference>

<reference anchor='RFC2234'>

<front>
<title abbrev='ABNF for Syntax Specifications'>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.H.' surname='Crocker' fullname='David H. Crocker'>
<organization>Internet Mail Consortium</organization>
<address>
<postal>
<street>675 Spruce Dr.</street>
<city>Sunnyvale</city>
<region>CA</region>
<code>94086</code>
<country>US</country></postal>
<phone>+1 408 246 8253</phone>
<facsimile>+1 408 249 6205</facsimile>
<email>dcrocker@imc.org</email></address></author>
<author initials='P.' surname='Overell' fullname='Paul Overell'>
<organization>Demon Internet Ltd</organization>
<address>
<postal>
<street>Dorking Business Park</street>
<street>Dorking</street>
<city>Surrey</city>
<region>England</region>
<code>RH4 1HN</code>
<country>UK</country></postal>
<email>paulo@turnpike.com</email></address></author>
<date month='November' year='1997' /></front>

<seriesInfo name='RFC' value='2234' />
</reference>


    </references>
  <references title='Informative References'>

<reference anchor='I-D.ietf-simple-message-sessions'>
<front>
<title>Instant Message Sessions in SIMPLE</title>

<author initials='B' surname='Campbell' fullname='Ben Campbell'>
    <organization />
</author>

<date month='Oct' day='22' year='2003' />
</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-simple-message-sessions-02' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-simple-message-sessions-02.txt' />
</reference>

<reference anchor='I-D.ietf-impp-cpim-msgfmt'>
<front>
<title>Common Presence and Instant Messaging: Message Format</title>

<author initials='D' surname='Atkins' fullname='Derek Atkins'>
    <organization />
</author>

<author initials='G' surname='Klyne' fullname='Graham Klyne'>
    <organization />
</author>

<date month='January' day='20' year='2003' />
</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-impp-cpim-msgfmt-08' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-impp-cpim-msgfmt-08.txt' />
</reference>





<reference anchor='RFC2326'>

<front>
<title abbrev='Real Time Streaming Protocol'>Real Time Streaming Protocol (RTSP)</title>
<author initials='H.' surname='Schulzrinne' fullname='Henning Schulzrinne'>
<organization>Columbia University, Dept. of Computer Science</organization>
<address>
<postal>
<street>1214 Amsterdam Avenue</street>
<city>New York</city>
<region>NY</region>
<code>10027</code>
<country>US</country></postal>
<email>schulzrinne@cs.columbia.edu</email></address></author>
<author initials='A.' surname='Rao' fullname='Anup Rao'>
<organization>Netscape Communications Corp.</organization>
<address>
<postal>
<street>501 E. Middlefield Road</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country></postal>
<email>anup@netscape.com</email></address></author>
<author initials='R.' surname='Lanphier' fullname='Robert Lanphier'>
<organization>RealNetworks</organization>
<address>
<postal>
<street>1111 Third Avenue</street>
<street>Suite 2900</street>
<city>Seattle</city>
<region>WA</region>
<code>98101</code>
<country>US</country></postal>
<email>robla@real.com</email></address></author>
<date month='April' year='1998' />
<abstract>
<t>The Real Time Streaming Protocol, or RTSP, is an application-level protocol for control over the delivery of data with real-time properties. RTSP provides an extensible framework to enable controlled, on-demand delivery of real-time data, such as audio and video. Sources of data can include both live data feeds and stored clips. This protocol is intended to control multiple data delivery sessions, provide a means for choosing delivery channels such as UDP, multicast UDP and TCP, and provide a means for choosing delivery mechanisms based upon RTP (RFC 1889).</t></abstract></front>

<seriesInfo name='RFC' value='2326' />
</reference>



<reference anchor='RFC2392'>

<front>
<title abbrev='Message- &amp; Content-ID URLs'>Content-ID and Message-ID Uniform Resource Locators</title>
<author initials='E.' surname='Levinson' fullname='Edward Levinson'>
<organization />
<address>
<postal>
<street>47 Clive Street</street>
<street>Metuchen</street>
<street>NJ  08840-1060</street>
<country>USA</country></postal>
<phone>+1 908 549 3716</phone>
<email>XIson@cnj.digex.net</email></address></author>
<date month='August' year='1998' />
<area>Applications</area>
<keyword>content-type</keyword>
<keyword>encapsulate</keyword>
<keyword>hypertext markup language</keyword>
<keyword>multipurpose internet mail extensions</keyword>
<keyword>uniform resource</keyword>
<abstract>
<t>
   The Uniform Resource Locator (URL) schemes, &quot;cid:&quot; and &quot;mid:&quot; allow
   references to messages and the body parts of messages.  For example,
   within a single multipart message, one HTML body part might include
   embedded references to other parts of the same message.
</t></abstract></front>

<seriesInfo name='RFC' value='2392' />
<format type='HTML' octets='23113' target='http://xml.resource.org/public/rfc/html/rfc2392.html' />
<format type='XML' octets='11888' target='http://xml.resource.org/public/rfc/xml/rfc2392.xml' />
</reference>



<reference anchor='RFC2779'>

<front>
<title abbrev='Instant Messaging/Presence Protocol'>Instant Messaging / Presence Protocol Requirements</title>
<author initials='M.' surname='Day' fullname='Mark Day'>
<organization>SightPath, Inc.</organization>
<address>
<postal>
<street>135 Beaver Street</street>
<city>Waltham</city>
<region>MA</region>
<code>02452</code>
<country>US</country></postal>
<email>mday@alum.mit.edu</email></address></author>
<author initials='S.' surname='Aggarwal' fullname='Sonu Aggarwal'>
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>One Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<email>sonuag@microsoft.com</email></address></author>
<author initials='J.' surname='Vincent' fullname='Jesse Vincent'>
<organization>Into Networks, Inc.</organization>
<address>
<postal>
<street>150 Cambridgepark Drive</street>
<city>Cambridge</city>
<region>MA</region>
<code>02140</code>
<country>US</country></postal>
<email>jesse@intonet.com</email></address></author>
<date month='February' year='2000' />
<abstract>
<t>Presence and Instant Messaging have recently emerged as a new medium of communications over the Internet.  Presence is a means for finding, retrieving, and subscribing to changes in the presence information (e.g. "online" or "offline") of other users. Instant messaging is a means for sending small, simple messages that are delivered immediately to online users.</t>
<t>Applications of presence and instant messaging currently use independent, non-standard and non-interoperable protocols developed by various vendors.  The goal of the Instant Messaging and Presence Protocol (IMPP) Working Group is to define a standard protocol so that independently developed applications of instant messaging and/or   presence can interoperate across the Internet. This document defines a minimal set of requirements that IMPP must meet.</t></abstract></front>

<seriesInfo name='RFC' value='2779' />
</reference>



<reference anchor='RFC2822'>

<front>
<title>Internet Message Format</title>
<author initials='P.' surname='Resnick' fullname='P. Resnick'>
<organization /></author>
<date month='April' year='2001' /></front>

<seriesInfo name='RFC' value='2822' />
</reference>



      <reference anchor='I-D.mahy-simple-session-relay-reqs'>
        <front>
            <title>Relay Requirements for Session-Mode Instant Messaging</title>
            <author initials='R' surname='Mahy'
                    fullname='Rohan Mahy'>
                <organization abbrev='Cisco'>
                        Cisco Systems
                </organization>
            </author>
            <date month='February' year='2004' />
        </front>
        <seriesInfo name='Internet-Draft' value='draft-mahy-simple-session-relay-reqs-00.txt'/>
      </reference>

      <reference anchor='I-D.mahy-simple-why-session-mode'>
        <front>
            <title>Benefits of Session-Mode Instant Messaging</title>
            <author initials='R' surname='Mahy'
                    fullname='Rohan Mahy'>
                <organization abbrev='Cisco'>
                        Cisco Systems
                </organization>
            </author>
            <date month='February' year='2004' />
        </front>
        <seriesInfo name='Internet-Draft' value='draft-mahy-simple-why-session-mode-00.txt'/>
      </reference>


  </references>
  
  
  </back>
</rfc>
