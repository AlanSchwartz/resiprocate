#!/bin/sh

# !!!!AVERT YOUR EYES!!!!

# No, seriously, I advise that you avoid looking too much at this file, for the
# sake of your mental health. It is the distillation of a great deal of 
# Cthulhu-level insanity, and I have gone to great lengths to sequester it here, 
# where no-one ever has to look at it again.

# Why are you still here?

# Ok, fine. Your funeral...

# Make HeaderHash.gperf

echo "%{
#include <string.h>
#include <ctype.h>
#include \"resip/stack/HeaderTypes.hxx\"

namespace resip
{
using namespace std;
%}
struct headers { char *name; Headers::Type type; };
%%" > HeaderHash.gperf

cat HeaderTypes.in | grep "^defineShort" | sed -Ee 's/defineShort\(([A-Za-z0-9]+),[ ]*\"([^"]+)\".*/\2, Headers::\1/' >> HeaderHash.gperf


cat HeaderTypes.in | grep -e "^defineHeader\|^defineMultiHeader" | sed -Ee 's/(defineHeader|defineMultiHeader)\(([A-Za-z0-9]+),[ ]*\"([^"]+)\".*/\3, Headers::\2/' >> HeaderHash.gperf

echo "%%
}" >> HeaderHash.gperf

# TODO move away from using the preprocessor here so that the generated files are reasonably readable.

# Make Headers.hxx.ixx.ixx
# We need to shell this inside Headers.hxx.ixx in order to handle the PARTIAL_TEMPLATE_SPECIALIZATION crap

echo "#define defineHeader(_enum, _name, _type, _rfc)                 \
class H_##_enum : public HeaderBase                             \
{                                                               \
   public:                                                      \
      RESIP_HeapCount(H_##_enum);                               \
      enum {Single = true};                                     \
      typedef _type Type;                                       \
      UnusedChecking(_enum);                                    \
      static Type& knownReturn(ParserContainerBase* container); \
      virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const;       \
      virtual Headers::Type getTypeNum() const;                 \
      virtual void merge(SipMessage&, const SipMessage&);       \
      H_##_enum();                                              \
};                                                              \
extern H_##_enum h_##_enum;

#define defineMultiHeader(_enum, _name, _type, _rfc)            \
class H_##_enum##s : public HeaderBase                          \
{                                                               \
   public:                                                      \
      RESIP_HeapCount(H_##_enum##s);                            \
      enum {Single = false};                                    \
      typedef ParserContainer<_type> Type;                      \
      MultiUnusedChecking(_enum);                               \
      static Type& knownReturn(ParserContainerBase* container); \
      virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const;       \
      virtual Headers::Type getTypeNum() const;                 \
      virtual void merge(SipMessage&, const SipMessage&);       \
      H_##_enum##s();                                           \
};                                                              \
extern H_##_enum##s h_##_enum##s;" > Headers.hxx.ixx.ixx.temp

cat HeaderTypes.in | grep -e "^defineHeader\|^defineMultiHeader" >> Headers.hxx.ixx.ixx.temp

# run preprocessor on Headers.hxx.ixx.temp
echo "// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know..." > Headers.hxx.ixx.ixx;

echo "// Generated by updateHeaders.sh " >> Headers.hxx.ixx.ixx;

gcc -E -x c++ Headers.hxx.ixx.ixx.temp | sed -Ee 's/#.*//' >> Headers.hxx.ixx.ixx
rm Headers.hxx.ixx.ixx.temp

# Make Headers.cxx.ixx

echo "#define defineHeader(_enum, _name, _type, _reference)                                                                   \
Headers::Type                                                                                                           \
H_##_enum::getTypeNum() const {return Headers::_enum;}                                                                  \
                                                                                                                        \
void H_##_enum::merge(SipMessage& target, const SipMessage& embedded)                                                   \
{                                                                                                                       \
   if (embedded.exists(*this))                                                                                          \
   {                                                                                                                    \
      target.header(*this) = embedded.header(*this);                                                                    \
   }                                                                                                                    \
}                                                                                                                       \
                                                                                                                        \
H_##_enum::H_##_enum()                                                                                                  \
{                                                                                                                       \
   Headers::CommaTokenizing[Headers::_enum+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti);   \
   Headers::CommaEncoding[Headers::_enum+1] = bool(Type::commaHandling & 2);                                            \
   Headers::HeaderNames[Headers::_enum+1] = _name;                                                                      \
   Headers::Multi[Headers::_enum+1] = false;                                                                             \
   HeaderBase::theHeaderInstances[Headers::_enum+1] = this;                                                                             \
}                                                                                                                       \
                                                                                                                        \
_type&                                                                                                                  \
H_##_enum::knownReturn(ParserContainerBase* container)                                                                  \
{                                                                                                                       \
   return dynamic_cast<ParserContainer<_type>*>(container)->front();                                                    \
}                                                                                                                       \
                                                                                                                        \
ParserContainerBase*                                                                                                    \
H_##_enum::makeContainer(HeaderFieldValueList* hfvs) const                                                              \
{                                                                                                                       \
   return new ParserContainer<_type>(hfvs,Headers::_enum);                                                              \
}                                                                                                                       \
                                                                                                                        \
H_##_enum resip::h_##_enum;

#define defineMultiHeader(_enum, _name, _type, _reference)                                                                              \
   Headers::Type                                                                                                                        \
H_##_enum##s::getTypeNum() const {return Headers::_enum;}                                                                               \
                                                                                                                                        \
void H_##_enum##s::merge(SipMessage& target, const SipMessage& embedded)                                                                \
{                                                                                                                                       \
   if (embedded.exists(*this))                                                                                                          \
   {                                                                                                                                    \
      target.header(*this).append(embedded.header(*this));                                                                              \
   }                                                                                                                                    \
}                                                                                                                                       \
                                                                                                                                        \
H_##_enum##s::H_##_enum##s()                                                                                                            \
{                                                                                                                                       \
   Headers::CommaTokenizing[Headers::_enum+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti);       \
   Headers::CommaEncoding[Headers::_enum+1] = bool(Type::value_type::commaHandling & 2);                                                \
   Headers::HeaderNames[Headers::_enum+1] = _name;                                                                                      \
   Headers::Multi[Headers::_enum+1] = true;                                                                             \
   HeaderBase::theHeaderInstances[Headers::_enum+1] = this;                                                                             \
}                                                                                                                                       \
                                                                                                                                        \
ParserContainer<_type>&                                                                                                                 \
H_##_enum##s::knownReturn(ParserContainerBase* container)                                                                               \
{                                                                                                                                       \
   return *dynamic_cast<ParserContainer<_type>*>(container);                                                                            \
}                                                                                                                                       \
                                                                                                                                        \
ParserContainerBase*                                                                                                    \
H_##_enum##s::makeContainer(HeaderFieldValueList* hfvs) const                                                           \
{                                                                                                                       \
   return new ParserContainer<_type>(hfvs,Headers::_enum);                                                              \
}                                                                                                                       \
                                                                                                                                        \
H_##_enum##s resip::h_##_enum##s;" > Headers.cxx.ixx.temp

cat HeaderTypes.in | grep -e "^defineHeader\|^defineMultiHeader" >> Headers.cxx.ixx.temp

echo "// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know..." > Headers.cxx.ixx;

echo "// Generated by updateHeaders.sh " >> Headers.cxx.ixx;

gcc -E -x c++ Headers.cxx.ixx.temp | sed -Ee 's/#.*//' >> Headers.cxx.ixx
rm Headers.cxx.ixx.temp

# Make SipMessage.hxx.ixx
echo "#define defineHeader(_header, _name, _type, _rfc)                       \
      const H_##_header::Type& header(const H_##_header& headerType) const; \
            H_##_header::Type& header(const H_##_header& headerType);
      
#define defineMultiHeader(_header, _name, _type, _rfc)                  \
      const H_##_header##s::Type& header(const H_##_header##s& headerType) const; \
            H_##_header##s::Type& header(const H_##_header##s& headerType);" >> SipMessage.hxx.ixx.temp

cat HeaderTypes.in | grep -e "^defineHeader\|^defineMultiHeader" >> SipMessage.hxx.ixx.temp

echo "// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know..." > SipMessage.hxx.ixx;

echo "// Generated by updateHeaders.sh " >> SipMessage.hxx.ixx;

gcc -E -x c++ SipMessage.hxx.ixx.temp | sed -Ee 's/#.*//' >> SipMessage.hxx.ixx
rm SipMessage.hxx.ixx.temp

# Make SipMessage.cxx.ixx
echo "#undef defineHeader
#define defineHeader(_header, _name, _type, _rfc)                                                       \
const H_##_header::Type&                                                                                \
SipMessage::header(const H_##_header& headerType) const                                                 \
{                                                                                                       \
   HeaderFieldValueList* hfvs = ensureHeaders(headerType.getTypeNum(), true);                           \
   if (hfvs->getParserContainer() == 0)                                                                 \
   {                                                                                                    \
      hfvs->setParserContainer(new ParserContainer<H_##_header::Type>(hfvs, headerType.getTypeNum()));  \
   }                                                                                                    \
   return dynamic_cast<ParserContainer<H_##_header::Type>*>(hfvs->getParserContainer())->front();       \
}                                                                                                       \
                                                                                                        \
H_##_header::Type&                                                                                      \
SipMessage::header(const H_##_header& headerType)                                                       \
{                                                                                                       \
   HeaderFieldValueList* hfvs = ensureHeaders(headerType.getTypeNum(), true);                           \
   if (hfvs->getParserContainer() == 0)                                                                 \
   {                                                                                                    \
      hfvs->setParserContainer(new ParserContainer<H_##_header::Type>(hfvs, headerType.getTypeNum()));  \
   }                                                                                                    \
   return dynamic_cast<ParserContainer<H_##_header::Type>*>(hfvs->getParserContainer())->front();       \
}

#undef defineMultiHeader
#define defineMultiHeader(_header, _name, _type, _rfc)                                          \
const H_##_header##s::Type&                                                                     \
SipMessage::header(const H_##_header##s& headerType) const                                      \
{                                                                                               \
   HeaderFieldValueList* hfvs = ensureHeaders(headerType.getTypeNum(), false);                  \
   if (hfvs->getParserContainer() == 0)                                                         \
   {                                                                                            \
      hfvs->setParserContainer(new H_##_header##s::Type(hfvs, headerType.getTypeNum()));        \
   }                                                                                            \
   return *dynamic_cast<H_##_header##s::Type*>(hfvs->getParserContainer());                     \
}                                                                                               \
                                                                                                \
H_##_header##s::Type&                                                                           \
SipMessage::header(const H_##_header##s& headerType)                                            \
{                                                                                               \
   HeaderFieldValueList* hfvs = ensureHeaders(headerType.getTypeNum(), false);                  \
   if (hfvs->getParserContainer() == 0)                                                         \
   {                                                                                            \
      hfvs->setParserContainer(new H_##_header##s::Type(hfvs, headerType.getTypeNum()));        \
   }                                                                                            \
   return *dynamic_cast<H_##_header##s::Type*>(hfvs->getParserContainer());                     \
}
" >> SipMessage.cxx.ixx.temp

cat HeaderTypes.in | grep -e "^defineHeader\|^defineMultiHeader" >> SipMessage.cxx.ixx.temp

echo "// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know..." > SipMessage.cxx.ixx;

echo "// Generated by updateHeaders.sh " >> SipMessage.cxx.ixx;

gcc -E -x c++ SipMessage.cxx.ixx.temp | sed -Ee 's/#.*//' >> SipMessage.cxx.ixx
rm SipMessage.cxx.ixx.temp


cat HeaderTypes.in | grep -e "^defineHeader\|^defineMultiHeader" | sed -Ee 's/(defineHeader|defineMultiHeader)\(([a-zA-Z0-9]+).*/\2,/'> HeaderTypes.hxx.ixx


# regenerate HeaderHash.cxx

if ! gperf -v > /dev/null 2>&1; then
   echo "gperf not installed. You need gperf to be able to update the set of supported headers.";
   exit;
fi

if ! gperf --ignore-case -D -E -L C++ -t -k '*' --compare-strncmp -Z HeaderHash HeaderHash.gperf > HeaderHash.cxx.try; then
   echo "Your version of gperf does not support the options we need.";
   exit;
fi

cp HeaderHash.cxx.try HeaderHash.cxx
rm HeaderHash.cxx.try

