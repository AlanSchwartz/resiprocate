#!/bin/sh

# Make HeaderHash.gperf

echo "%{
#include <string.h>
#include <ctype.h>
#include \"resip/stack/HeaderTypes.hxx\"

namespace resip
{
using namespace std;
%}
struct headers { char *name; Headers::Type type; };
%%" > HeaderHash.gperf

cat HeaderTypes.in | grep "^defineShort" | sed -Ee 's/defineShort\(([A-Za-z0-9]+),[ ]*\"([^"]+)\".*/\2, Headers::\1/' >> HeaderHash.gperf


cat HeaderTypes.in | grep -e "^defineHeader\|^defineMultiHeader" | sed -Ee 's/(defineHeader|defineMultiHeader)\(([A-Za-z0-9]+),[ ]*\"([^"]+)\".*/\3, Headers::\2/' >> HeaderHash.gperf

echo "%%
}" >> HeaderHash.gperf

# Make Headers.hxx.ixx.ixx
# We need to shell this inside Headers.hxx.ixx in order to handle the PARTIAL_TEMPLATE_SPECIALIZATION crap

echo "// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know..." > Headers.hxx.ixx.ixx;

echo "// Generated by updateHeaders.sh " >> Headers.hxx.ixx.ixx;

echo "#define defineHeader(_enum, _name, _type, _rfc)                              \\
class H_##_enum : public HeaderBase                                                \\
{                                                                                  \\
   public:                                                                         \\
      RESIP_HeapCount(H_##_enum);                                                  \\
      enum {Single = true};                                                        \\
      typedef _type Type;                                                          \\
      UnusedChecking(_enum);                                                       \\
      static Type& knownReturn(ParserContainerBase* container);                    \\
      virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const;\\
      virtual Headers::Type getTypeNum() const;                                    \\
      virtual void merge(SipMessage&, const SipMessage&);                          \\
      H_##_enum();                                                                 \\
};                                                                                 \\
extern H_##_enum h_##_enum;

#define defineMultiHeader(_enum, _name, _type, _rfc)                               \\
class H_##_enum##s : public HeaderBase                                             \\
{                                                                                  \\
   public:                                                                         \\
      RESIP_HeapCount(H_##_enum##s);                                               \\
      enum {Single = false};                                                       \\
      typedef ParserContainer<_type> Type;                                         \\
      MultiUnusedChecking(_enum);                                                  \\
      static Type& knownReturn(ParserContainerBase* container);                    \\
      virtual ParserContainerBase* makeContainer(HeaderFieldValueList* hfvs) const;\\
      virtual Headers::Type getTypeNum() const;                                    \\
      virtual void merge(SipMessage&, const SipMessage&);                          \\
      H_##_enum##s();                                                              \\
};                                                                                 \\
extern H_##_enum##s h_##_enum##s;

#define defineShort(_enum, _name) 
" >> Headers.hxx.ixx.ixx

cat HeaderTypes.in  >> Headers.hxx.ixx.ixx

echo "#undef defineHeader
#undef defineMultiHeader
#undef defineShort" >> Headers.hxx.ixx.ixx

# Make Headers.cxx.ixx

echo "// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know..." > Headers.cxx.ixx;

echo "// Generated by updateHeaders.sh " >> Headers.cxx.ixx;

echo "#define defineHeader(_enum, _name, _type, _reference)                                                          \\
Headers::Type                                                                                                        \\
H_##_enum::getTypeNum() const {return Headers::_enum;}                                                               \\
                                                                                                                     \\
void H_##_enum::merge(SipMessage& target, const SipMessage& embedded)                                                \\
{                                                                                                                    \\
   if (embedded.exists(*this))                                                                                       \\
   {                                                                                                                 \\
      target.header(*this) = embedded.header(*this);                                                                 \\
   }                                                                                                                 \\
}                                                                                                                    \\
                                                                                                                     \\
H_##_enum::H_##_enum()                                                                                               \\
{                                                                                                                    \\
   Headers::CommaTokenizing[Headers::_enum+1] = bool(Type::commaHandling & ParserCategory::CommasAllowedOutputMulti);\\
   Headers::CommaEncoding[Headers::_enum+1] = bool(Type::commaHandling & 2);                                         \\
   Headers::HeaderNames[Headers::_enum+1] = _name;                                                                   \\
   Headers::Multi[Headers::_enum+1] = false;                                                                         \\
   HeaderBase::theHeaderInstances[Headers::_enum+1] = this;                                                          \\
}                                                                                                                    \\
                                                                                                                     \\
_type&                                                                                                               \\
H_##_enum::knownReturn(ParserContainerBase* container)                                                               \\
{                                                                                                                    \\
   return dynamic_cast<ParserContainer<_type>*>(container)->front();                                                 \\
}                                                                                                                    \\
                                                                                                                     \\
ParserContainerBase*                                                                                                 \\
H_##_enum::makeContainer(HeaderFieldValueList* hfvs) const                                                           \\
{                                                                                                                    \\
   return new ParserContainer<_type>(hfvs,Headers::_enum);                                                           \\
}                                                                                                                    \\
                                                                                                                     \\
H_##_enum resip::h_##_enum;

#define defineMultiHeader(_enum, _name, _type, _reference)                                                                       \\
   Headers::Type                                                                                                                 \\
H_##_enum##s::getTypeNum() const {return Headers::_enum;}                                                                        \\
                                                                                                                                 \\
void H_##_enum##s::merge(SipMessage& target, const SipMessage& embedded)                                                         \\
{                                                                                                                                \\
   if (embedded.exists(*this))                                                                                                   \\
   {                                                                                                                             \\
      target.header(*this).append(embedded.header(*this));                                                                       \\
   }                                                                                                                             \\
}                                                                                                                                \\
                                                                                                                                 \\
H_##_enum##s::H_##_enum##s()                                                                                                     \\
{                                                                                                                                \\
   Headers::CommaTokenizing[Headers::_enum+1] = bool(Type::value_type::commaHandling & ParserCategory::CommasAllowedOutputMulti);\\
   Headers::CommaEncoding[Headers::_enum+1] = bool(Type::value_type::commaHandling & 2);                                         \\
   Headers::HeaderNames[Headers::_enum+1] = _name;                                                                               \\
   Headers::Multi[Headers::_enum+1] = true;                                                                                      \\
   HeaderBase::theHeaderInstances[Headers::_enum+1] = this;                                                                      \\
}                                                                                                                                \\
                                                                                                                                 \\
ParserContainer<_type>&                                                                                                          \\
H_##_enum##s::knownReturn(ParserContainerBase* container)                                                                        \\
{                                                                                                                                \\
   return *dynamic_cast<ParserContainer<_type>*>(container);                                                                     \\
}                                                                                                                                \\
                                                                                                                                 \\
ParserContainerBase*                                                                                                             \\
H_##_enum##s::makeContainer(HeaderFieldValueList* hfvs) const                                                                    \\
{                                                                                                                                \\
   return new ParserContainer<_type>(hfvs,Headers::_enum);                                                                       \\
}                                                                                                                                \\
                                                                                                                                 \\
H_##_enum##s resip::h_##_enum##s;

#define defineShort(_enum, _name) 
" >> Headers.cxx.ixx

cat HeaderTypes.in >> Headers.cxx.ixx

echo "#undef defineHeader
#undef defineMultiHeader
#undef defineShort" >> Headers.cxx.ixx

# Make SipMessage.hxx.ixx
echo "// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know..." > SipMessage.hxx.ixx;

echo "// Generated by updateHeaders.sh " >> SipMessage.hxx.ixx;

echo "#define defineHeader(_header, _name, _type, _rfc)                       \\
      const H_##_header::Type& header(const H_##_header& headerType) const;   \\
            H_##_header::Type& header(const H_##_header& headerType);
      
#define defineMultiHeader(_header, _name, _type, _rfc)                            \\
      const H_##_header##s::Type& header(const H_##_header##s& headerType) const; \\
            H_##_header##s::Type& header(const H_##_header##s& headerType);

#define defineShort(_enum, _name) 
" >> SipMessage.hxx.ixx

cat HeaderTypes.in >> SipMessage.hxx.ixx

echo "#undef defineHeader
#undef defineMultiHeader
#undef defineShort" >> SipMessage.hxx.ixx


# Make SipMessage.cxx.ixx

echo "// !bwc! I apologize that this is so ugly. If you know of a standard GNU utility that will re-indent uglified c++ code (like this), let me know..." > SipMessage.cxx.ixx;

echo "// Generated by updateHeaders.sh " >> SipMessage.cxx.ixx;

echo "#undef defineHeader
#define defineHeader(_header, _name, _type, _rfc)                                                       \\
const H_##_header::Type&                                                                                \\
SipMessage::header(const H_##_header& headerType) const                                                 \\
{                                                                                                       \\
   HeaderFieldValueList* hfvs = ensureHeaders(headerType.getTypeNum(), true);                           \\
   if (hfvs->getParserContainer() == 0)                                                                 \\
   {                                                                                                    \\
      hfvs->setParserContainer(new ParserContainer<H_##_header::Type>(hfvs, headerType.getTypeNum()));  \\
   }                                                                                                    \\
   return dynamic_cast<ParserContainer<H_##_header::Type>*>(hfvs->getParserContainer())->front();       \\
}                                                                                                       \\
                                                                                                        \\
H_##_header::Type&                                                                                      \\
SipMessage::header(const H_##_header& headerType)                                                       \\
{                                                                                                       \\
   HeaderFieldValueList* hfvs = ensureHeaders(headerType.getTypeNum(), true);                           \\
   if (hfvs->getParserContainer() == 0)                                                                 \\
   {                                                                                                    \\
      hfvs->setParserContainer(new ParserContainer<H_##_header::Type>(hfvs, headerType.getTypeNum()));  \\
   }                                                                                                    \\
   return dynamic_cast<ParserContainer<H_##_header::Type>*>(hfvs->getParserContainer())->front();       \\
}

#undef defineMultiHeader
#define defineMultiHeader(_header, _name, _type, _rfc)                                          \\
const H_##_header##s::Type&                                                                     \\
SipMessage::header(const H_##_header##s& headerType) const                                      \\
{                                                                                               \\
   HeaderFieldValueList* hfvs = ensureHeaders(headerType.getTypeNum(), false);                  \\
   if (hfvs->getParserContainer() == 0)                                                         \\
   {                                                                                            \\
      hfvs->setParserContainer(new H_##_header##s::Type(hfvs, headerType.getTypeNum()));        \\
   }                                                                                            \\
   return *dynamic_cast<H_##_header##s::Type*>(hfvs->getParserContainer());                     \\
}                                                                                               \\
                                                                                                \\
H_##_header##s::Type&                                                                           \\
SipMessage::header(const H_##_header##s& headerType)                                            \\
{                                                                                               \\
   HeaderFieldValueList* hfvs = ensureHeaders(headerType.getTypeNum(), false);                  \\
   if (hfvs->getParserContainer() == 0)                                                         \\
   {                                                                                            \\
      hfvs->setParserContainer(new H_##_header##s::Type(hfvs, headerType.getTypeNum()));        \\
   }                                                                                            \\
   return *dynamic_cast<H_##_header##s::Type*>(hfvs->getParserContainer());                     \\
}

#define defineShort(_enum, _name) 
" >> SipMessage.cxx.ixx

cat HeaderTypes.in >> SipMessage.cxx.ixx

echo "#undef defineHeader
#undef defineMultiHeader
#undef defineShort" >> SipMessage.cxx.ixx

# Make HeaderTypes.hxx.ixx
cat HeaderTypes.in | grep -e "^defineHeader\|^defineMultiHeader" | sed -Ee 's/(defineHeader|defineMultiHeader)\(([a-zA-Z0-9]+).*/\2,/'> HeaderTypes.hxx.ixx

# regenerate HeaderHash.cxx

if ! gperf -v > /dev/null 2>&1; then
   echo "gperf not installed. You need gperf to be able to update the set of supported headers.";
   exit;
fi

if ! gperf --ignore-case -D -E -L C++ -t -k '*' --compare-strncmp -Z HeaderHash HeaderHash.gperf > HeaderHash.cxx.try; then
   echo "Your version of gperf does not support the options we need.";
   exit;
fi

cp HeaderHash.cxx.try HeaderHash.cxx
rm HeaderHash.cxx.try

